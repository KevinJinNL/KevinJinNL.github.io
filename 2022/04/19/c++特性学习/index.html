<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Kevin&#39;s Blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://example.com">
    <!--SEO-->

<meta name="keywords" content="" />


<meta name="description" content="c++特性学习指针
引用 引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d时声明的变量名..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    C++ |
    
    Kevin&#39;s Blog
</title>

<link rel="alternate" href="/atom.xml" title="Kevin&#39;s Blog" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.1.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.4pvt8z0ci5y0.webp)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Kevin'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://example.com">
                        Kevin&#39;s Blog</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/CS基础/"><i class="fa "></i>
                                CS基础</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/语言学习/"><i class="fa "></i>
                                语言学习</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/杂谈/"><i class="fa "></i>
                                杂谈</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="C++">
            
            C++
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2022/04/19</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="c-特性学习"><a href="#c-特性学习" class="headerlink" title="c++特性学习"></a>c++特性学习</h1><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p> 引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d时声明的变量名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int val=1024;</span><br><span class="line">int &amp;refVal=ival;//refVal指向ival</span><br><span class="line">int &amp;refVal2;//报错：引用必须被初始化</span><br></pre></td></tr></table></figure>

<hr>
<p> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的</span><br><span class="line">refVal=2;//把2赋给refVal指向的对象，此处即是赋给了ival</span><br><span class="line">int ii=refVal;//与ii=ival执行结果一样</span><br><span class="line"></span><br><span class="line">//允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头</span><br><span class="line">int i=1024,i2=2048;//i和i2都是int</span><br><span class="line">int &amp;r=i,r2=i2;//r是一个引用，与i绑定在一起，r2是int</span><br><span class="line">int i3=1024，&amp;ri=i3;//i3是int，ri是一个引用，与i3绑定在一起</span><br><span class="line">int &amp;r3=i3,&amp;r2=i2;//r3和r4都是引用</span><br></pre></td></tr></table></figure>

<h2 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h2><p> 指针(pointer)是“指向”(point to)，与引用类似，指针也实现了对其他对象的间接访问，但是1.指针本身就是一个对象，允许对指针赋值和拷贝。2.指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int *ip1,*ip2;//ip1和ip2都是指向int型对象的指针</span><br><span class="line">int val=42;</span><br><span class="line">int *p=&amp;ival;//p存放变量ival的地址，或者说p是指向变量ival的指针</span><br><span class="line"></span><br><span class="line">double dval;</span><br><span class="line">double *pd=&amp;dval;//正确，初始值是double型对象的地址</span><br><span class="line">double *pd2=pd;//正确：初始值是指向double对象的指针</span><br><span class="line"></span><br><span class="line">int *pi=pd;//错误：指针pi的类型和pd的类型不匹配</span><br><span class="line">pi=&amp;dval;//错误：试图把double型对象的地址赋给int型指针</span><br></pre></td></tr></table></figure>

<p>指针值</p>
<p> 指针的值(即地址)应属下列4种状态之一：</p>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针，意味着指针没有指向任何对象</li>
<li>无效指针，也就是上述情况之外的其他值</li>
</ol>
<p>利用指针访问对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ival=42;</span><br><span class="line">int *p=&amp;ival; //p存放着变量ival的地址，或者说p是指向变量ival的指针</span><br><span class="line">cout&lt;&lt;*p; //由符号*得到指针p所指的对象</span><br><span class="line"></span><br><span class="line">*p=0; //由符号*得到指针p所指的对象，即可经由p位变量ival赋值</span><br><span class="line">cout&lt;&lt;*p;//输出0</span><br></pre></td></tr></table></figure>

<p>空指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p1=nullptr;</span><br><span class="line">int *p2=0;</span><br><span class="line">int *p3=NULL;</span><br></pre></td></tr></table></figure>

<hr>
<p>建议：使用指针的时候，一定要进行初始化，使用未经初始化的指针是引发运行时错误的一大原因</p>
<p>指针赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">int *pi=0;//pi被初始化，但没有指向任何对象</span><br><span class="line">int *pi2=&amp;i;//pi2被初始化，存有i的地址</span><br><span class="line">int *pi3;//如果pi3定义于块内，则pi3的值是无法确定的</span><br><span class="line"></span><br><span class="line">pi3=pi2;//pi3和pi2指向同一个对象</span><br><span class="line">pi2=0;//现在pi2不指向任何对象了</span><br><span class="line"></span><br><span class="line">pi=&amp;ival;//pi的值被改变，现在pi指向了ival</span><br><span class="line">*pi=0;//ival的值被改变，指针pi没有改变，也就是*pi(也就是指针pi指向的那个对象)发生改变</span><br></pre></td></tr></table></figure>

<p>void*指针</p>
<p> void<em>是一种特殊的的指针类型，可用于存放任意对象的地址。一个void</em>指针存放着一个地址，这一点和其他指针类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double obj=3.14,*pd=&amp;obj;</span><br><span class="line">//正确，void*能存放任意类型对象的地址</span><br><span class="line">void *pv=&amp;obj；//obj可以是任意类型的对象</span><br><span class="line">pv=pd；//pv可以存放任意类型的指针</span><br></pre></td></tr></table></figure>

<p>指向指针的指针</p>
<p> 一般来说，声明符中修饰符的个数并没有限制，当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival=1024;</span><br><span class="line">int *pi=&amp;ival;//pi指向一个int型的数</span><br><span class="line">int **ppi=&amp;pi;//ppi指向一个int型的指针</span><br></pre></td></tr></table></figure>

<p>指向指针的引用</p>
<p> 引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">int *p;//p是一个int型指针</span><br><span class="line">int *&amp;r=p;//r是一个对指针p的引用</span><br><span class="line"></span><br><span class="line">r=&amp;i;//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span><br><span class="line">*r=0;//解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure>

<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><hr>
<p> 有时我们希望定义这样一种变量，它的值不能改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。另一方面，也应随时警惕程序一不小心改变了这个值。为了满足这一要求，可以用关键字const对变量的类型加以限定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize=512;//输入缓冲区大小</span><br><span class="line">bufSize=512;//错误，试图向const对象写值</span><br><span class="line"></span><br><span class="line">const int i=get_size();//正确：运行时初始化</span><br><span class="line">const int j=42;//正确：编译时初始化</span><br><span class="line">const int k;//错误：k是一个未经初始化的变量</span><br></pre></td></tr></table></figure>

<p>默认状态下，const对象仅在文件内有效</p>
<p> 当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize=512；//输入缓冲区大小</span><br></pre></td></tr></table></figure>

<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换</p>
<hr>
<p> 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//解决方法是加上extern关键字即可</span><br><span class="line">//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span><br><span class="line">extern const int bufSize=fcn();</span><br><span class="line">//file_1.h头文件</span><br><span class="line">extern const int bufSize;//与file_1.cc中定义的bufSize是同一个</span><br></pre></td></tr></table></figure>

<p>初始化和对const的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">const int &amp;r1=i;//允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2=42;//正确，r1是一个常量引用</span><br><span class="line">const int &amp;r3=r1*2;//正确:r3是一个常量引用</span><br><span class="line">int &amp;r4=r1*2;//错误：r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>

<hr>
<p> 必须认识到，常量引用仅对引用可参与的操作作出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">int &amp;r1=i;//引用ri绑定对象i</span><br><span class="line">const int &amp;r2=i;//r2也绑定对象i，但是不允许通过r2修改i的值</span><br><span class="line">r1=0//r1并非常量，i的值可以修改为0</span><br><span class="line">r2=0;//错误：无法修改</span><br></pre></td></tr></table></figure>

<p> 指向常量的指针(pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const double pi=3.14;//pi是个常量，它的值不能改变</span><br><span class="line">double *ptr=&amp;pi;//错误：ptr是一个普通指针</span><br><span class="line">const double *cptr=&amp;pi;//正确：cptr可以指向一个双精度常量</span><br><span class="line">*cptr=42;//错误：不能给*cptr赋值</span><br></pre></td></tr></table></figure>

<h2 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h2><p> 指针是对象而引用不是，因此迹象其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址)就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int errNumb=0;</span><br><span class="line">int *const curErr=&amp;errNumb;//curErr将一直指向errNumb</span><br><span class="line">const double pi=3.14159;</span><br><span class="line">const double *const pip=&amp;pi;//pip是一个指向常量对象的常量指针</span><br><span class="line"></span><br><span class="line">*pip=2.72;//错误：pip是一个指向常量的指针</span><br><span class="line">		 //如果curErr所指的对象(也就是errNumb)的值不为0</span><br><span class="line">if(*curErr)&#123;</span><br><span class="line">    errorHandler();</span><br><span class="line">    *curErr=0;//正确：把curErr所指的对象的值重置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶层const</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">int *const p1=&amp;i;//不能改变p1的值,这是一个顶层const</span><br><span class="line">const int ci=42;//不能改变ci的值，这是一个顶层const</span><br><span class="line">const int *p2=&amp;ci;//允许改变p2的值，这是一个底层const</span><br><span class="line">const int *const p3=p2;//靠右的const是顶层const，靠左的是底层const</span><br><span class="line">const int &amp;r=ci;//用于声明引用的const都是底层const</span><br><span class="line"></span><br><span class="line">i=ci;//正确：拷贝ci的值，ci是一个顶层const，对此操作无影响</span><br><span class="line">p2=p3;//正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响</span><br><span class="line">    </span><br><span class="line">int *p=p3;//错误：p3包含底层const的定义，而p没有</span><br><span class="line">p2=p3;//正确：p2和p3都是底层const</span><br><span class="line">p2=&amp;i;//正确：int*能转换成const int*</span><br><span class="line">int &amp;r=ci;//错误：普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int &amp;r2=i;//正确const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<hr>
<p> 指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词<strong>顶层const</strong>(top-level const)表示指针本身是个常量，而用名词<strong>底层const</strong>(low-level const)表示指针所指的对象是一个常量</p>
<p> 更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其它类型相比区别明显：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">int *const p1=&amp;i;//不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci=42;//不能改变ci的值，这是一个顶层const</span><br><span class="line">const int *p2=&amp;ci;//允许改变p2的值，这是一个底层const</span><br><span class="line">const int *const p3=p2;//靠右的const是顶层const，靠左的是底层const</span><br><span class="line">const int &amp;r=ci;//用于声明引用的const都是底层const\</span><br><span class="line"></span><br><span class="line">//拷贝时，顶层const不受什么影响，拷入和拷出对象是否是常量没什么影响</span><br><span class="line">//底层const限制不能忽视，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行</span><br><span class="line">int *p=p3;//错误：p3包含底层const的定义，而p没有</span><br><span class="line">p2=p3;//正确：p2和p3都是底层const</span><br><span class="line">p2=&amp;i;//正确：int*能转换成const int*</span><br><span class="line">int &amp;r=ci;//错误：普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int &amp;r2=i;//正确：const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p> 一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>(sequential container)为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应</p>
<h2 id="顺序容器类型"><a href="#顺序容器类型" class="headerlink" title="顺序容器类型"></a>顺序容器类型</h2><ul>
<li><p>vector：可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</p>
</li>
<li><p>deque：双端队列。支持快速随机访问。在头尾位置插入&#x2F;删除速度很快</p>
</li>
<li><p>list：双向链表。只支持双向顺序访问。在list中任何位置进行插入&#x2F;删除操作速度都很快</p>
</li>
<li><p>forward：单向链表。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作都很快</p>
</li>
<li><p>array：固定大小数组。支持快速随机访问，不能添加或删除元素</p>
</li>
<li><p>string：与vector相似的容器，但专门用于保存<strong>字符</strong>。随机访问快。在尾部插入&#x2F;删除速度快</p>
<hr>
<p>以下是选择容器时的基本原则</p>
<ul>
<li>如果没有绝对的理由，使用vector</li>
<li>如果程序有很多小元素且对额外空间开销要求很高，则<strong>不要</strong>使用list或者forward_list</li>
<li>程序要求随机访问元素，使用vector或者deque</li>
<li>如果要在容器中间位置进行增删操作，使用list或者forward_list</li>
<li>头尾位置增删，使用deque</li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p> 迭代器的元素范围为左闭合区间，标准数学描述为</p>
<p> [begin,end)</p>
<p> 使用迭代器访问元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">for(it=vec.begin();it!=vec.end();it++)</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl</span><br></pre></td></tr></table></figure>

<h2 id="类型成员"><a href="#类型成员" class="headerlink" title="类型成员"></a>类型成员</h2><p> 每个容器都定义了多个类型，我们熟悉的有三种：size_type,iterator,const_iterator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//iter时通过list&lt;string&gt;定义的一个迭代器类型</span><br><span class="line">list&lt;string&gt;::iterator iter;</span><br><span class="line">//count时通过vector&lt;int&gt;定义的一个difference_type类型</span><br><span class="line">vector&lt;int&gt;::difference_type count;</span><br></pre></td></tr></table></figure>

<p> 容器中还有begin和end操作，生成指向容器中第一个元素和尾元素之后位置的迭代器，而成员中也有begin和end类，即为左闭合区间的范围</p>
<h2 id="容器拷贝"><a href="#容器拷贝" class="headerlink" title="容器拷贝"></a>容器拷贝</h2><p> 两个容器拷贝时，要求两个容器的数据类型和容器类型都要匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//每个容器由三个元素，用给定的初始化器进行初始化</span><br><span class="line">list&lt;string&gt; authors=&#123;&quot;Milton&quot;,&quot;Shakespeare&quot;,&quot;Austen&quot;&#125;;</span><br><span class="line">vector&lt;const char*&gt; articles=&#123;&quot;a&quot;,&quot;an&quot;,&quot;the&quot;&#125;;</span><br><span class="line"></span><br><span class="line">list&lt;string&gt; list2(authors);//正确：数据类型以及容器类型都匹配</span><br><span class="line">deque&lt;string&gt; authList(authors);//错误：容器类型不匹配</span><br><span class="line">vector&lt;string&gt; words(arcticles);//错误：容器类型必须匹配</span><br><span class="line">//正确：可以将const char*元素转换为string</span><br><span class="line">forward_list&lt;string&gt; words(articles.begin(),articles.end());</span><br><span class="line"></span><br><span class="line">//拷贝元素，直到it指向的元素</span><br><span class="line">deque&lt;string&gt; authList(authors.begin(),it);</span><br></pre></td></tr></table></figure>

<h2 id="容器元素构造"><a href="#容器元素构造" class="headerlink" title="容器元素构造"></a>容器元素构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(10,-1); //10个int元素，每个都初始化为-1</span><br><span class="line">list&lt;string&gt; svec(10,&quot;hi!&quot;); //10个strings；每个都初始化为&quot;hi!&quot;</span><br><span class="line">forward_list&lt;int&gt; ivec(10); //10个元素，每个都初始化为0</span><br><span class="line">deque&lt;string&gt; svec(10); //10个元素，每个都是空string</span><br></pre></td></tr></table></figure>

<h2 id="容器赋值运算"><a href="#容器赋值运算" class="headerlink" title="容器赋值运算"></a>容器赋值运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c1=c2;//将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型</span><br><span class="line"></span><br><span class="line">c=&#123;a,b,c.......&#125;;//基本初始化/拷贝方法</span><br><span class="line"></span><br><span class="line">swap(c1,c2)，c1.swap(c2);//交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多</span><br><span class="line"></span><br><span class="line">seq.assign(b,e);//将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</span><br><span class="line"></span><br><span class="line">seq.assign(il);//将seq中的元素替换为初始化列表il中的元素</span><br><span class="line"></span><br><span class="line">seq.assign(n,t);//将seq中的元素替换为n个值为t的元素</span><br></pre></td></tr></table></figure>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//array不支持这些操作</span><br><span class="line">//forward_list有自己专有版本的insert和emplace且不支持push_back和emplace_back</span><br><span class="line">//vector和string不支持push_front和emplace—_front</span><br><span class="line"></span><br><span class="line">c.push_back(t); //在c的尾部插入元素</span><br><span class="line">c.emplace_back(arg)s;//在c的尾部创建由args创建的元素</span><br><span class="line"></span><br><span class="line">c.push_front同理于back操作</span><br></pre></td></tr></table></figure>

<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">at和下标操作只适用于string,vector,deque和array</span><br><span class="line">back不适用于forward_list</span><br><span class="line">c.back();//返回c中尾元素的引用。若c为空，函数行为未定义</span><br><span class="line">c.front();//返回c中首元素的引用。若c为空，函数行为未定义</span><br><span class="line">c[n];//返回c中下标为n的元素的引用，n是一个无符号正数。若n&gt;=c.size(),则函数行为未定义</span><br><span class="line">c.at(n);//返回下标为n的元素的引用。如果下标越界，则抛出out_of_range的异常</span><br></pre></td></tr></table></figure>

<p>访问成员函数返回的是引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!c.empty())&#123;</span><br><span class="line">	c.front()=42; //将42赋予c中的第一个元素</span><br><span class="line">	auto &amp;v=c.back(); //获得指向最后一个元素的引用</span><br><span class="line">	v=1024; //改变c中的元素</span><br><span class="line">	auto v2=c.back(); //v2不是一个引用，它是c.back()的一个拷贝</span><br><span class="line">	v2=0;	//未改变c中的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.pop_back();//删除c中尾元素，若c为空，函数行为未定义，函数返回void</span><br><span class="line">c.erase();//删除迭代器p所指定的元素，返回一个指向被删元素之后的元素的迭代器，若p指向尾元素，则返回尾后(off-the-end)迭代器。若p是尾后迭代器，则函数行为未定义</span><br><span class="line">c.clear();//删除c中所有元素</span><br></pre></td></tr></table></figure>

<h2 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h2><p>向容器添加元素后</p>
<ul>
<li>对于vector和string，且存储空间被重回新分配，则指向容器的迭代器、指针、引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针、引用都会失效</li>
<li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首位位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效</li>
<li>list和forward_list总是有效</li>
</ul>
<p>删除元素后，指向被删除元素的迭代器、指针、引用都会失效</p>
<hr>
<p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector,string和deque尤为重要</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p> 为了支持快速随机访问，vector将元素连续存储，vector通常会分配比新的空间需求更大的内存空间预留作为备用</p>
<p>vector管理容量的成员函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shrink_to_fit//只适用于vector，string和deque</span><br><span class="line">capacity和reserve//只适用于vector和string</span><br><span class="line">c.shrink_to_fit()；//请将capacity()减少为与size()相同大小</span><br><span class="line">c.capacity();//不重新分配内存空间的话，c可以保存多少元素</span><br><span class="line">c.reserve();//分配至少能容纳n个元素的内存空间，预留空间时可用</span><br></pre></td></tr></table></figure>

<hr>
<p> 只有在执行insert操作时size与capacity相等，或者调用resize或reserve时给定的大小超过当前capacity，vector才可能重新分配内存空间。会分配多少超过给定容量的额外空间，取决于具体实现</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>构造string</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s(cp,n);//s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符</span><br><span class="line">string s(s2,pos2);//s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义</span><br><span class="line">string s(s2,pos2,len2);//s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;s2.size()，函数行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符</span><br></pre></td></tr></table></figure>

<p>substr操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;);</span><br><span class="line">string s2=s.substr(0,5);//s2=hello</span><br><span class="line">string s3=s.substr(6);//s3=world</span><br><span class="line">string s4=s.substr(6,11);//s3=world</span><br><span class="line">string s5=s.substr(12);//抛出一个out_of_range异常</span><br></pre></td></tr></table></figure>

<p>改变string的其他方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s.insert(s.size(),5,&#x27;!&#x27;);//在s末尾插入5个感叹号</span><br><span class="line">s.erase(s.size()-5,5)；//从s删除最后5个字符</span><br><span class="line">const char*cp=&quot;Stately,plump Buck&quot;;</span><br><span class="line">s.assign(cp,7);//s==&quot;Stately&quot;</span><br><span class="line">s.insert(s.size(),cp+7);//s==&quot;Stately,plump Buck&quot;</span><br><span class="line"></span><br><span class="line">string s=&quot;some string&quot;,s2=&quot;some other string&quot;;</span><br><span class="line">s.insert(0,s2);//在s中位置0之前插入s2的拷贝</span><br><span class="line">//在s[0]之前插入s2中s2[0]开始的s2.size()个字符</span><br><span class="line">s.insert(0,s2,0,s2.size());</span><br></pre></td></tr></table></figure>

<p>append和replace函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;C++ Primer&quot;),s2=s;//将s和s2初始化为&quot;C++ Primer&quot;</span><br><span class="line">s.insert(s.size(),&quot;4th Ed.&quot;);//s==&quot;C++ Primer 4th Ed.&quot;</span><br><span class="line">s2.append(&quot;4th Ed.&quot;);//s2==&quot;C++ Primer 4th Ed.&quot;</span><br><span class="line">//将&quot;4th&quot;替换为&quot;5th&quot;的等价方法</span><br><span class="line">s.erase(11,3);//s==&quot;C++ Primer Ed.&quot;</span><br><span class="line">s.insert(11,&quot;5th&quot;);//s==&quot;C++ Primer 5th Ed.&quot;</span><br><span class="line">//从位置11开始，删除3个字符并插入&quot;5th&quot;</span><br><span class="line">s2.replace(11,3,&quot;5th&quot;);//此例中调用replace时，插入的文本恰好与删除的文本一样长。这不是必须的，可以插入一个更长或更短的string</span><br></pre></td></tr></table></figure>

<p>string搜索操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string name(&quot;AnnaBelle&quot;);</span><br><span class="line">auto pos1=name.find(&quot;Anna&quot;);//pos1==0</span><br><span class="line">//这一段返回0，即子字符串&quot;Anna&quot;在&quot;AnnaBelle&quot;中第一次出现的下标</span><br><span class="line"></span><br><span class="line">string lowercase(&quot;annabelle&quot;);</span><br><span class="line">pos1=lowercase.find(&quot;Anna&quot;);//pos1==npos</span><br><span class="line"></span><br><span class="line">string numbers(&quot;0123456789&quot;),name(&quot;r2d2&quot;);//返回1即name中第一个数字的下标</span><br><span class="line">auto pos=name.find_first_of(numbers);</span><br><span class="line"></span><br><span class="line">string dept(&quot;03714p3&quot;);</span><br><span class="line">//返回5--字符&#x27;p&#x27;的下标</span><br><span class="line">auto pos=dept.find_first_not_of(numbers);</span><br></pre></td></tr></table></figure>

<p>搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos=0;</span><br><span class="line">//每步循环查找name中下一个数</span><br><span class="line">while((pos=name.find_first_of(numbers,pos))!=string::npos)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;found number at index:&quot;&lt;&lt;pos&lt;&lt;&quot;element is&quot;&lt;&lt;name[pos]&lt;&lt;endl;</span><br><span class="line">	++pos;//移动到下一个字符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compare函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;kevin&quot;);</span><br><span class="line">cout&lt;&lt;s.compare(&quot;kevin&quot;)&lt;&lt;endl;//输出为1</span><br></pre></td></tr></table></figure>

<p>数值转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">string s=to_string(i);//将整数i转换为字符表示形式</span><br><span class="line">double d=stod(S);//将字符串s转换为浮点数</span><br></pre></td></tr></table></figure>

<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p> 除了顺序容器外，标准库还定义了三个顺序容器适配器:stack,quene和priorty_queue，适配器是标准库中的一个通用概念，一个适配器是一种机制，能使某种事物的行为看起来像一种不同的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//所有容器适配器都支持的操作和类型</span><br><span class="line">size_type//一种类型</span><br><span class="line">value_type//元素类型</span><br><span class="line">container_type//实现适配器的底层容器类型</span><br><span class="line">A a;//创建一个名为a的空适配器</span><br><span class="line">A a(c);//创建一个带有c拷贝名为a的适配器</span><br><span class="line">关系运算符</span><br><span class="line">a.empty()//若a包含任何元素，返回false，否则返回true</span><br><span class="line">a.size()//返回a中的元素数目</span><br><span class="line">swap(a,b)//交换a和b的内容，a和b数据类型和容器类型必须相同</span><br><span class="line">a.swap(b)//同上</span><br></pre></td></tr></table></figure>

<p>定义一个适配器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//假设deq是一个deque&lt;int&gt;，我们可以用deq来初始化一个新的stack</span><br><span class="line">stack&lt;int&gt; stk(deq);//从deq拷贝元素到stk</span><br><span class="line">//在vector上实现的空栈</span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; str_stk;</span><br><span class="line">//str_stk2在vector上实现，初始化时保存sevc的拷贝</span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; str_stk2(svec);</span><br></pre></td></tr></table></figure>

<p>栈适配器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; intstack;//空栈</span><br><span class="line">//填满栈</span><br><span class="line">for(size_t ix=0;ix!=10;++ix)</span><br><span class="line">	intstack.push(ix);//intstack保存0到9十个数</span><br><span class="line">while(!intstack.empty())&#123;//intstack中有值就继续循环</span><br><span class="line">	int value=intstack.pop();</span><br><span class="line">	//使用栈顶值的代码</span><br><span class="line">	intstack.pop();//弹出栈顶元素，继续循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><hr>
<h2 id="IO库类型和头文件"><a href="#IO库类型和头文件" class="headerlink" title="IO库类型和头文件"></a>IO库类型和头文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//头文件</span><br><span class="line">iostream			istream,wistream从流读取数据</span><br><span class="line">    				ostream,wostream向流写入数据</span><br><span class="line">    				iostream,wiostream读写流</span><br><span class="line">fstream				ifstream，wifsteam从文件读取数据</span><br><span class="line">    				ofstream，wofstream向文件写入数据</span><br><span class="line">    				fstream，wfstream读写文件</span><br><span class="line">sstream				istringstream，wistringstream从string读取数据</span><br><span class="line">    				ostringstream，wistringstream向string写入数据</span><br><span class="line">    				stringstream，wstringstream读写string</span><br></pre></td></tr></table></figure>

<h2 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out,out2;</span><br><span class="line">out1=ou2;//错误：不能对流对象赋值</span><br><span class="line">ofstream print(ofstream);//错误：不能初始化ofstream参数</span><br><span class="line">out2=print(out2);//错误:不能拷贝流对象</span><br></pre></td></tr></table></figure>

<h2 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h2><p> IO操作一个与生俱来的问题就是可能发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strm::iostate  strm是一种IO类型</span><br><span class="line">strm::badbit   strm::babit用来指出流已崩溃</span><br><span class="line">strm::failbit  strm::failbit用来指出一个IO操作失败了</span><br><span class="line">strm::eofbit   strm::eofbit用来指出流到达了文件结束</span><br><span class="line">strm::goodbit  strm::goodbit用来指出流未处于错误状态。此值保证为零</span><br></pre></td></tr></table></figure>

<p> 一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><hr>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><hr>
<p>在了解线程之前，我们可以先了解一下线程、进程之间的区别以及联系</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p> 进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式和的描述，进程是程序的实体</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p> 线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务，线程是独立调度和分派的基本单位，线程可以为操作系统内核调度的内核线程，如win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用火狐进程，如windows7的线程，进行混合调度</p>
<p> 一个进程可以有很多线程，每条线程并行执行不同的任务</p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2022/04/19/Java%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/" class="pre-post btn btn-default" title='Java'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            Java</span>
    </a>
    
    
</div>

<div id="comments">
    
    
<div class="utteranc">
  
  <script
    src='https://utteranc.es/client.js'
    repo='shenliyang/snippet-comment'
    issue-term='pathname'
    issue-number=''
    theme='github-light'
    label=''
    crossorigin='anonymous'
    async
  ></script>
</div>



</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0"><span class="toc-text">c++特性学习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88-1"><span class="toc-text">指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E6%8C%87%E9%92%88"><span class="toc-text">const指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">顺序容器类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-text">类型成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8B%B7%E8%B4%9D"><span class="toc-text">容器拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E6%9E%84%E9%80%A0"><span class="toc-text">容器元素构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-text">容器赋值运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-text">访问元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text">容器操作可能使迭代器失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-text">string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">容器适配器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%BA%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">IO库类型和头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%8B%B7%E8%B4%9D%E6%88%96%E8%B5%8B%E5%80%BC"><span class="toc-text">IO对象无拷贝或赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-text">条件状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>