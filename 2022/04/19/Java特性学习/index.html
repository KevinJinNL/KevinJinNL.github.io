<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Kevin&#39;s Blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://example.com">
    <!--SEO-->

<meta name="keywords" content="" />


<meta name="description" content="一、类和对象
 java作为一门面向对象的程序设计语言，在java中所有的东西都会属于某个类（class），你会建立的是源文件（扩展名为.java），然后将它编译成新的文件（扩展名为.class..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    Java |
    
    Kevin&#39;s Blog
</title>

<link rel="alternate" href="/atom.xml" title="Kevin&#39;s Blog" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.1.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.4pvt8z0ci5y0.webp)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Kevin'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://example.com">
                        Kevin&#39;s Blog</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/CS基础/"><i class="fa "></i>
                                CS基础</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/语言学习/"><i class="fa "></i>
                                语言学习</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/杂谈/"><i class="fa "></i>
                                杂谈</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Java">
            
            Java
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2022/04/19</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h1><hr>
<p> java作为一门面向对象的程序设计语言，在java中所有的东西都会属于某个类（class），你会建立的是源文件（扩展名为.java），然后将它编译成新的文件（扩展名为.class），实际上真正执行的是类class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//一个狗的示例类</span><br><span class="line">class dog&#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">    //数据成员</span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(&quot;小狗吃东西&quot;)；</span><br><span class="line">    &#125;</span><br><span class="line">    //抽象行为</span><br><span class="line">    public void Needfood(int food)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(&quot;小狗要吃&quot;+food+&quot;克狗食&quot;)；</span><br><span class="line">    &#125;</span><br><span class="line">    //成员方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在上面的小狗类示例中，可以发现一个类有几种基本元素</p>
<ul>
<li>数据成员(Data)</li>
<li>抽象行为(Abstract Behavior)</li>
<li>成员方法(Method)</li>
</ul>
<h2 id="对象的继承-Inheritance"><a href="#对象的继承-Inheritance" class="headerlink" title="对象的继承(Inheritance)"></a>对象的继承(Inheritance)</h2><p> 首先我们想象这么一个场景，两位programmer接到了相同的任务，要求在图形接口画出四方形，圆形与三角形，当用户点选图形时，图形需要顺时针转动360°并依据形状的不同播放不同音频文件，我们分别称呼两位programmer为一号和二号</p>
<hr>
<p>一号的设计思路是这样的，写出旋转以及播放音频函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rotate(shapeNum)</span><br><span class="line">&#123;</span><br><span class="line">    //旋转360°</span><br><span class="line">&#125;//旋转函数</span><br><span class="line">playsound(shapeNum)</span><br><span class="line">&#123;</span><br><span class="line">    //播放对应音频文件</span><br><span class="line">&#125;//音频播放函数</span><br></pre></td></tr></table></figure>

<p>而二号的设计思路是将需求的三个类都写出来并且每一个类都对其旋转和音频播放函数进行定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Square&#123;//正方形</span><br><span class="line">    rotate()&#123;</span><br><span class="line">        //旋转函数</span><br><span class="line">    &#125;</span><br><span class="line">    playsound()&#123;</span><br><span class="line">        //音频播放函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle()&#123;//圆形</span><br><span class="line">    rotate()&#123;</span><br><span class="line">        //旋转函数</span><br><span class="line">    &#125;</span><br><span class="line">    playsound()&#123;</span><br><span class="line">        //音频播放函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Triangle()&#123;//三角形</span><br><span class="line">	rotate()&#123;</span><br><span class="line">        //旋转函数</span><br><span class="line">    &#125;</span><br><span class="line">    playsound()&#123;</span><br><span class="line">        //音频播放函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 综上可以看出，一号的代码量要少很多，但是可读性以及后期针对不同需求的时候需要修改，比如我们增加一个阿米巴虫形状，一号的程序代码就需要针对阿米巴虫形状进行专门的修改,以至于后期如果增加更多的类和不同情况下的需求，需要在playsound函数中增加大量的分支语句，无论是读起来还是理解起来都非常吃力(如果还不是自己写的)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">playsound(shapeNum)&#123;</span><br><span class="line">	//如果不是阿米巴虫形状</span><br><span class="line">		//查询使用哪个音频文件</span><br><span class="line">		//播放</span><br><span class="line">	//不然</span><br><span class="line">		//播放阿米巴虫对应的音频文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 而二号在可读性以及后期的修改上就要轻松很多，但是代码量要多得多，而且真正修改起来还得寻找相应的对象，也是非常麻烦，只要有新的需求就需要重新写入一个类</p>
<p> 由此在这种情况下我们就可以用到java中继承(inheritance)的特性，利用<strong>extends</strong>关键字，创建最顶层的类shape类,shape类具有包括正方形长方形三角形等几何图形所具有的共同特征以及特性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class shape&#123;</span><br><span class="line">    double area;//面积</span><br><span class="line">    String name;//图形名称</span><br><span class="line">    </span><br><span class="line">    void rotate()</span><br><span class="line">    &#123;</span><br><span class="line">        //图形旋转</span><br><span class="line">    &#125;</span><br><span class="line">    void playsound()</span><br><span class="line">    &#123;</span><br><span class="line">        //播放音频文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面我们定义了顶层的图形类shape，在定义其他图形时可以直接继承shape类的各种数据成员以及方法，例如直接让三角形继承shape类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Triangle extends shape&#123;</span><br><span class="line">    //此处我们可以直接对shape中已有的方法进行重写override</span><br><span class="line">    </span><br><span class="line">    void rotate()&#123;</span><br><span class="line">        //三角形旋转的具体实现</span><br><span class="line">    &#125;</span><br><span class="line">    void playsound()&#123;</span><br><span class="line">        //三角形旋转时播放的音频文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载-Override"><a href="#重载-Override" class="headerlink" title="重载(Override)"></a>重载(Override)</h3><p> 如果想要继承的对象其中的某一个方法不按主类的具体方法实现，可以采取对方法进行重载的方式，只需要在子类中定义具体的实现方法即可</p>
<h2 id="控制对象"><a href="#控制对象" class="headerlink" title="控制对象"></a>控制对象</h2><hr>
<ul>
<li><p>事实上并没有对象变量这样的东西存在</p>
</li>
<li><p>只有引用(reference)到对象的变量</p>
</li>
<li><p>对象引用变量保存的是存取对象的方法</p>
<hr>
<p>对象的声明、创建与赋值有3个步骤：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//以Dog类为例</span><br><span class="line">Dog mydog=new Dog();</span><br></pre></td></tr></table></figure>

<p> 在其背后的具体实现细节分为三步：</p>
<p>一、声明一个引用变量</p>
<p> <strong>Dog myDog</strong>&#x3D;new Dog();</p>
<p> 要求Java虚拟机分配空间给引用变量，并将此变量命名为myDog，此引用变量将永远被固定为Dog类型，换句话说，它是个控制Dog的遥控器</p>
<p>二、创建对象</p>
<p> Dog myDog&#x3D;<strong>new Dog()</strong>;</p>
<p> 要求Java虚拟机分配堆空间给新建立的Dog对象</p>
<p>三、连接对象和引用</p>
<p> Dog myDog**&#x3D;**new Dog();</p>
<p> 将新的Dog赋值给myDog这个引用变量</p>
<h2 id="对象中的变量"><a href="#对象中的变量" class="headerlink" title="对象中的变量"></a>对象中的变量</h2><hr>
<p> 在Java对象中，有实例变量和局部变量两种变量，实例变量时声明在类中，而局部变量是声明在方法中的</p>
<p>实例变量声明在类中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Horse&#123;</span><br><span class="line">    private double height=15.2;</span><br><span class="line">    private String breed;</span><br><span class="line">   	//more code......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部变量声明在方法中且局部变量没有默认值，如果在变量被初始前就被使用的话，编译器就会显示错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">    public void go()</span><br><span class="line">    &#123;</span><br><span class="line">        int x;</span><br><span class="line">        int z=x+3;//无法编译，x并未初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h2><hr>
<p> 在Java中，运算符“&#x3D;&#x3D;”可以用于比较两个引用是否指向同一对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo a=new Foo();</span><br><span class="line">Foo b=new Foo();</span><br><span class="line">Foo c=a;</span><br><span class="line">a==b;//false</span><br><span class="line">a==c;//true</span><br><span class="line">b==c;//false</span><br></pre></td></tr></table></figure>

<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><hr>
<p> this关键字出现在类的构造方法中时，代表使用该构造方法所创建的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class People&#123;</span><br><span class="line">	int leg,hand;</span><br><span class="line">	String name;</span><br><span class="line">	People(String s)&#123;</span><br><span class="line">		name=s;</span><br><span class="line">        this.init();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    void init()&#123;</span><br><span class="line">        leg=2;</span><br><span class="line">        hand=2;</span><br><span class="line">        System.out.println(name+&quot;有&quot;+hand+&quot;只手&quot;+leg+&quot;条腿&quot;)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        People boshi=new People(&quot;布什&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><hr>
<p> 一个类声明的两个对象如果具有相同的引用，那么二者就具有完全相同的实体，而且Java有所谓的“垃圾收集”机制，这种机制周期地检测某个实体是否已不再被任何对象所拥有(引用),如果发现这样的实体，就释放实体占有的内存</p>
<h2 id="类与程序的基本结构"><a href="#类与程序的基本结构" class="headerlink" title="类与程序的基本结构"></a>类与程序的基本结构</h2><hr>
<p> 一个Java应用程序(Project)由若干个类构成，这些类可以在一个源文件中，也可以分布在若干个源文件中。</p>
<p> Java应用程序有一个主类，即含有main方法的类，Java应用程序从主类的main方法开始执行。在编写一个Java应用程序时，可以编写若干个Java源文件，每个源文件编译后产生若干个类的字节码文件</p>
<h2 id="实例方法和类方法的区别"><a href="#实例方法和类方法的区别" class="headerlink" title="实例方法和类方法的区别"></a>实例方法和类方法的区别</h2><hr>
<p>1.对象调用实例方法</p>
<p> 实例方法中不仅可以操作实例变量，也可以操作类变量。当对象调用实例方法时，该方法中出现的实例变量就是分配给该对象的实例变量，该方法中出现的类变量也是分配给该对象的变量，只不过这个变量和所有的其他对象共享而已</p>
<p>2.类名调用类方法</p>
<p> 与实例方法不同，类方法不可以操作实例变量，这是因为在类创建对象之前，实例成员变量还没有分配内存</p>
<p>3.设计类方法的原则</p>
<p> 对于static方法，不必创建对象就可以用类名直接调用它，如果一个方法不需要操作类中的任何实例变量，就可以满足程序的需要，考虑将这样的方法设计为一个static方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array类示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> []a=&#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">45</span>,<span class="number">90</span>,<span class="number">123</span>,<span class="number">19</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><hr>
<ol>
<li>规划程序时要考虑未来</li>
<li>用继承来防止子类中出现重复的代码</li>
<li>寻找更多抽象化的机会</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Doctor</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> worksAtHospital;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">treatPatient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行检查</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FamilyDoctor</span> <span class="keyword">extends</span> <span class="title class_">Doctor</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> makesHouseCalls;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveAdvice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//提出诊断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Surgeon</span> <span class="keyword">extends</span> <span class="title class_">Doctor</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">treatPatient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//进行手术</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeIncision</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//截肢</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><hr>
<p> instanceof是Java独有的双目运算符，其左面的操作元是对象，右面的操作元是类，当左面的操作元是右面的类或其子类所创建的对象时，instanceof运算的结果是true，否则是false</p>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><hr>
<p>重写的语法规则</p>
<p> 如果子类可以继承父类的某个方法，那么子类就有权利重写这个方法。所谓方法重写，是指子类中定义一个方法，这个方法的类型和父类的方法的类型一致</p>
<p>重写的目的</p>
<p> 重写方法既可以操作继承的成员变量、调用继承的方法，也可以操作子类新声明的成员变量、调用新定义的其他方法，但无法操作被子类隐藏的成员变量和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">computer</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">computer</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    B b=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">double</span> result=b.computer(<span class="number">8</span>,<span class="number">9</span>);<span class="comment">//b调用重写的方法</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="type">int</span> m=b.g(<span class="number">12</span>,<span class="number">8</span>);<span class="comment">//b调用继承的方法</span></span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，如果子类如下定义computer方法，将产生编译错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double computer(float x,float y)&#123;</span><br><span class="line">	return x*y;</span><br><span class="line">&#125;</span><br><span class="line">//因为父类的computer方法类型是float，子类的computer方法类型没有和父类的computer方法保持一致</span><br><span class="line"></span><br><span class="line">//重写的注意事项</span><br><span class="line">//重写父类的方法时，不允许降低方法的访问权限，但可以提高访问权限(public,protected,friendly,private)</span><br></pre></td></tr></table></figure>

<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><hr>
<p> 用super操作被隐藏的成员变量和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">float</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            sum=sum+i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Average</span> <span class="keyword">extends</span> <span class="title class_">Sum</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">float</span> c;</span><br><span class="line">        <span class="built_in">super</span>.n=n;</span><br><span class="line">        c=<span class="built_in">super</span>.f();</span><br><span class="line">        <span class="keyword">return</span> c/n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">g</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">float</span> c;</span><br><span class="line">        c=<span class="built_in">super</span>.f();</span><br><span class="line">        <span class="keyword">return</span> c/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 有人认为super和this引用是类似的概念，实际上这样比较并不恰当因为super不是一个对象的引用，它只是一个指示编译器调用超类方法的关键字</p>
<p> 子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承类的任何域和方法</p>
<h2 id="阻止继承-final类和方法"><a href="#阻止继承-final类和方法" class="headerlink" title="阻止继承:final类和方法"></a>阻止继承:final类和方法</h2><p> 有时候，可能希望组织人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Executive</span> <span class="keyword">extends</span> <span class="title class_">Manager</span></span><br><span class="line">&#123;</span><br><span class="line">    ....<span class="comment">//无法定义Executive 的子类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//类中的特定方法可以被声明为final，这样子类就不能覆盖这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、接口-Interface-与多态"><a href="#三、接口-Interface-与多态" class="headerlink" title="三、接口(Interface)与多态"></a>三、接口(Interface)与多态</h1><hr>
<h2 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h2><p>​	把抽象类放在这一章节是因为抽象类与接口之间具有很高的学习联系价值，对抽象类的理解有助于我们对接口的学习，并且可以更加深刻的理解面向对象编程即面向抽象编程的思维</p>
<p>​	用关键词<strong>abstract</strong>修饰的类称为抽象类，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	用关键词<strong>abstract</strong>修饰的方法称为抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">p</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>在抽象类中，有几点以下原则</p>
<ul>
<li>abstract类中可以有abstract方法</li>
<li>abstract类不能用new运算符创建对象</li>
<li>对于abstract类的子类，必须重写父类的abstract的发给发，即去掉父类的abstract的修饰并写出具体的方法体，如果子类也是abstract类，既可以选择重写，也可以选择继承</li>
<li>可以使用abstract类声明对象，虽然不能用<strong>new</strong>运算符创建该对象，但是该对象可以成为其子类对象的上转型对象，该对象可以调用子类重写后的方法</li>
</ul>
<p>具象化为代码，我们可以想象出以下情况</p>
<p>​	有一个柱体，我们需要通过代码求出柱体的体积，但是柱体的底面有很多种，可能是三角形，也可能是圆形等等</p>
<p><strong>我们可以发现，无论柱体的底面是什么形状的，都有一个共同的行为，那就是有一个求出自身面积的行为，所以我们可以直接通过一个抽象类服务于不同形状的底面</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Geometry</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pillar</span>&#123;</span><br><span class="line">    Geometry bottom;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    Pillar(Geometry bottom,<span class="type">double</span> height)&#123;</span><br><span class="line">        <span class="built_in">this</span>.bottom=bottom;<span class="built_in">this</span>.height=height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getVolume</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bottom==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有底，无法计算体积&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bottom.getArea()*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Geometry</span>&#123;</span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    Rectangle(<span class="type">double</span> a,<span class="type">double</span> b)&#123;</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">        <span class="built_in">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Pillar pillar;</span><br><span class="line">        Geometry bottom=<span class="literal">null</span>;</span><br><span class="line">        pillar = <span class="keyword">new</span> <span class="title class_">Pillar</span>(bottom,<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;体积&quot;</span>+pillar.getVolume());</span><br><span class="line">        bottom=<span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">12</span>,<span class="number">22</span>);</span><br><span class="line">        pillar =<span class="keyword">new</span> <span class="title class_">Pillar</span>(bottom,<span class="number">58</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;体积&quot;</span>+pillar.getVolume());</span><br><span class="line">        bottom=nnew <span class="title function_">Circle</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">        pillar=<span class="keyword">new</span> <span class="title class_">Pillar</span>(bottom,<span class="number">58</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;体积&quot;</span>+pillar.getVolume());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>使用关键字<strong>interface</strong>来定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口体</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Printable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> MAX=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">sum</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	接口体中包含常量的声明和<strong>抽象方法</strong>两部分，接口体中只有抽象方法，没有普通的方法，而且接口体中所有的常量的访问权限一定都是public,而且都是static常量，所有的抽象方法的访问权限一定都是public</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>在Java中，类实现接口时使用的是<strong>implements</strong>关键字，实现多个接口时用逗号分隔开不同的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Printable</span>,Addable</span><br></pre></td></tr></table></figure>

<h2 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h2><p>​	如果一个<strong>非抽象类</strong>实现了某个接口，那么这个类<strong>必须</strong>重写接口中的所有方法，同时因为接口中的所有方法都是public abstract的修饰，所以当重写时一定要<strong>明显地用public</strong>修饰重写(不然访问权限降级，这在java中是不允许的)的方法，并且去掉abstract关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Computable</span>&#123;</span><br><span class="line">    <span class="type">int</span> MAX=<span class="number">46</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">China</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Japan</span> <span class="keyword">implements</span> <span class="title class_">Computable</span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> MAX+x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        China zhang;</span><br><span class="line">        Japan henlu;</span><br><span class="line">        zhang=<span class="keyword">new</span> <span class="title class_">China</span>();</span><br><span class="line">        henlu=<span class="keyword">new</span> <span class="title class_">Japan</span>();</span><br><span class="line">        zhang.number=<span class="number">32</span>+Computable.MAX;<span class="comment">//这里可以直接访问接口中的常量，因为其访问权限为public</span></span><br><span class="line">        henlu.number=<span class="number">14</span>+Computable.MAX;</span><br><span class="line">        System.out.println(zhang.f(<span class="number">100</span>));</span><br><span class="line">        System.out.println(henlu.f(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	而对于抽象类，抽象类既可以重写接口中方法，也可以直接拥有接口中的方法</p>
<p>​	一个类如果实现了接口，那么该类可以直接在类体中使用该接口中的常量</p>
<h2 id="接口回调"><a href="#接口回调" class="headerlink" title="接口回调"></a>接口回调</h2><p>​	接口回调我认为是一个非常重要的概念，他跟多态的实现有着非常紧密的联系，如下有两个类实现了同一接口，同一个接口可以实现两个不同对象的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ShowMessage</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 显示商标(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span> <span class="keyword">implements</span> <span class="title class_">ShowMessage</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 显示图标(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PC</span> <span class="keyword">implements</span> <span class="title class_">ShowMessage</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 显示商标(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ShowMessage sm;</span><br><span class="line">        sm=<span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        sm.显示商标(<span class="string">&quot;长城牌电视机&quot;</span>);</span><br><span class="line">    	sm=<span class="keyword">new</span> <span class="title class_">PC</span>();</span><br><span class="line">        sm.显示商标(<span class="string">&quot;联想奔月5008PC机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口与多态"><a href="#接口与多态" class="headerlink" title="接口与多态"></a>接口与多态</h2><p>​	多态和接口有着不可分割的紧密关系，由接口产生的多态就是指不同的类在实现同一个接口时可能具有不同的实现方式，即接口在不同类中重新定义的函数体不同，有点像函数的重载**(或许？)**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SpeakHello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下三个类实现了同一个接口，但是接口中的实现方法分别都不一样，同一接口在不同的类中具有不同的实现方式，此为多态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span> <span class="keyword">implements</span> <span class="title class_">SpeakHello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">British</span> <span class="keyword">implements</span> <span class="title class_">SpeakHello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Japanese</span> <span class="keyword">implements</span> <span class="title class_">SpeakHello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时接口也可以作为参数，通过实现了同一个接口的不同类可以调用具体类中接口的不同实现方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloSample</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Hello</span><span class="params">(SpeakHello speakhello)</span>&#123;</span><br><span class="line">        speakhello.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        HelloSample hi=<span class="keyword">new</span> <span class="title class_">HelloSample</span>();</span><br><span class="line">        hi.Hello(<span class="keyword">new</span> <span class="title class_">Chinese</span>());</span><br><span class="line">        hi.Hello(<span class="keyword">new</span> <span class="title class_">Japanese</span>());</span><br><span class="line">        hi.Hello(<span class="keyword">new</span> <span class="title class_">British</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行后，结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你好！</span><br><span class="line">こんにちは</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure>

<h2 id="abstract类与接口的比较"><a href="#abstract类与接口的比较" class="headerlink" title="abstract类与接口的比较"></a>abstract类与接口的比较</h2><p>​	经过学习，我们发现抽象类与接口在某些程度上具有很高的重合度，但是两者也是具有很多区别的，就比如Java不支持类的多重继承，多重继承只能够通过实现多个接口来实现，两者具有如下诸多区别</p>
<ul>
<li><strong>abstract类</strong>和<strong>接口</strong>都可以有abstract方法</li>
<li><strong>接口</strong>中只可以有常量不可以有变量，但是<strong>abstract类</strong>中既可以有常量也可以有变量</li>
<li><strong>abstract类</strong>中也可以有非abstract方法，但是<strong>接口</strong>不可以</li>
</ul>
<h1 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h1><hr>
<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/95E5970199A464DDC0D26DF54031951A.2wl267rdkgc.jpg" alt="95E5970199A464DDC0D26DF54031951A"></p>
<h2 id="Collection超类"><a href="#Collection超类" class="headerlink" title="Collection超类"></a>Collection超类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span><span class="comment">//返回一个用于访问集合中元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span><span class="comment">//返回当前集合中元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span><span class="comment">//集合中没有元素，则返回true</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Obeject obj)</span><span class="comment">//如果集合中包含了一个与obj相等的对象，返回true</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsALL</span><span class="params">(Collection&lt;?&gt; other)</span><span class="comment">//如果这个集合包括other集合中的所有元素，返回true</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object element)</span><span class="comment">//将一个元素添加到集合中。如果由于这个调用改变了集合，返回true</span></span><br><span class="line">j</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; other)</span><span class="comment">//将other集合中所有元素添加到这个集合</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span><span class="comment">//从这个集合中删除等于obj的对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; other)</span><span class="comment">//删除other集合中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span><span class="comment">//从这个集合中删除所有的元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainALL</span><span class="params">(Collection&lt;?&gt; other)</span><span class="comment">//从这个集合删除所有与other集合中的元素不同的元素</span></span><br><span class="line"></span><br><span class="line">Object[] toArray()<span class="comment">//返回这个集合的对象数组</span></span><br></pre></td></tr></table></figure>

<h1 id="五、常用类"><a href="#五、常用类" class="headerlink" title="五、常用类"></a>五、常用类</h1><hr>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p> 在Java中，<strong>String类</strong>具有不可扩展，不可继承的特性，因为在Java中String类被定义为final类</p>
<p><strong>常量池</strong></p>
<p> 在Java中，常量池是一个非常重要的概念，因为String常量是对象，所以也有自己的<strong>引用</strong>和<strong>实体</strong>，他们都存放在常量池中</p>
<p> 可以这样理解常量池:<strong>常量池中的数据在程序运行期间再也不允许改变,而凡是通过new构造出的对象都不在常量池中</strong></p>
<p><strong>声明对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;we are students&quot;</span>);</span><br><span class="line">String t=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;we are students&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们还可以通过使用字符数组的方式声明String类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]=&#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>(a,<span class="number">0</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.4d9sm9g5d920.webp" alt="image"></p>
<p><strong>获取字符串的长度</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name=<span class="string">&quot;Kevin&quot;</span>;</span><br><span class="line"><span class="type">int</span> len=name.length();</span><br></pre></td></tr></table></figure>

<p><strong>比较两个字符串</strong></p>
<p>public boolean equal(String s)</p>
<p>要注意的是，这里的equal方法只判断两个字符串的内容，并不判断他们在常量池中是否指向同一对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String tom=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Kevin&quot;</span>);</span><br><span class="line">String boy=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Keivn&quot;</span>);</span><br><span class="line">tom==boy;<span class="comment">//false</span></span><br><span class="line">tom.equals(boy);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>前后缀比较</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String tom=<span class="string">&quot;天气预报&quot;</span>,jerry=<span class="string">&quot;比赛结果&quot;</span>;</span><br><span class="line">tom.startsWith(<span class="string">&quot;天气&quot;</span>);<span class="comment">//true</span></span><br><span class="line">jerry.endsWith(<span class="string">&quot;结果&quot;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="String类常用API"><a href="#String类常用API" class="headerlink" title="String类常用API"></a>String类常用API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本API</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s)</span>;<span class="comment">//判断父字符串中是否有字符串s的序列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String s)</span>;<span class="comment">//字符串s在父字符串中第一次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String s)</span>;<span class="comment">//字符串s在父字符串中最后一次出现的位置</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> startpoint,<span class="type">int</span> endpoint)</span>;<span class="comment">//截取字符串中从startpoint下标到endpoint的子字符串，如果不填写endpoint参数则默认为从startpoint一直截取到末尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串转换为数据类型为int</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">String s=<span class="string">&quot;876&quot;</span>;</span><br><span class="line">x=Integer.parseInt(s);<span class="comment">//parseInt用到的地方很多，尤其是在需要得到字符串转换为数字的情况下</span></span><br><span class="line"><span class="comment">//int数据转换为字符串类型</span></span><br><span class="line">String str=String.valueOf(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String字符串转换为字符数组</span></span><br><span class="line"><span class="type">char</span> [] a,c;</span><br><span class="line">String s=<span class="string">&quot;1945年8月15日是抗战胜利日&quot;</span>;</span><br><span class="line">a=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];</span><br><span class="line">s.getChars(<span class="number">11</span>,<span class="number">15</span>,a,<span class="number">0</span>);<span class="comment">//数组a存放的是&#x27;抗&#x27;,&#x27;战&#x27;,&#x27;胜&#x27;,&#x27;利&#x27;</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">c=<span class="string">&quot;十一长假期间，学校都放假了&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c.length();i++)&#123;</span><br><span class="line">    System.out.print(c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于字符串数字之间的交换，这里我们给出一个例子，我个人认为是比较有意义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">double</span> sum=<span class="number">0</span>,item=<span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> computable=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s:args)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                item=Double.parseDouble(s);</span><br><span class="line">                sum+=item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入了非数字字符:&quot;</span>+e);</span><br><span class="line">                computable=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(computable)</span><br><span class="line">            System.out.printlb(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借用牛客网上的一道字符串相关的题目，有几个点需要注意一下</p>
<p>1.在Java中，字符串<strong>String</strong>是不允许更改的，所以在coding时我们经常用<strong>StringBuffer、StringBuilder</strong>构造之后再进行操作</p>
<p>2.一般的算法题，因为传递的参数都是<strong>String</strong>类，但是由于我们一般用<strong>StringBuffer、StringBuilder</strong>操作，所以在返回时需要用API：**toString()**更改返回值的类型</p>
<p><strong>将一个由英文字母组成的字符串转换成从末尾开始每三个字母用逗号分隔的形式</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hellonowcoder</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h,ell,ono,wco,der</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"></span><br><span class="line">        StringBuilder newstr=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=str.length()-<span class="number">3</span>;i&gt;=<span class="number">0</span>;i-=<span class="number">3</span>)&#123;</span><br><span class="line">            newstr.insert(i,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(newstr.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2022/04/19/StoryOfOS/" class="pre-post btn btn-default" title='Story of OS'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            Story of OS</span>
    </a>
    
    
    <a href="/2022/04/19/c++%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/" class="next-post btn btn-default" title='C++'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            C++</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
    
<div class="utteranc">
  
  <script
    src='https://utteranc.es/client.js'
    repo='shenliyang/snippet-comment'
    issue-term='pathname'
    issue-number=''
    theme='github-light'
    label=''
    crossorigin='anonymous'
    async
  ></script>
</div>



</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">一、类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF-Inheritance"><span class="toc-text">对象的继承(Inheritance)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-Override"><span class="toc-text">重载(Override)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">控制对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">对象中的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">对象的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">this关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-text">垃圾收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">类与程序的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">实例方法和类方法的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-text">二、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">instanceof运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BF-final%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">阻止继承:final类和方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3-Interface-%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="toc-text">三、接口(Interface)与多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-abstract"><span class="toc-text">抽象类(abstract)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="toc-text">定义接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">接口的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83"><span class="toc-text">接口回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="toc-text">接口与多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">abstract类与接口的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-text">四、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E8%B6%85%E7%B1%BB"><span class="toc-text">Collection超类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">五、常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-text">String类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8API"><span class="toc-text">String类常用API</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>