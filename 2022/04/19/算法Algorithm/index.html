<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Kevin&#39;s Blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://example.com">
    <!--SEO-->

<meta name="keywords" content="" />


<meta name="description" content="不同数据范围下，代码的时间复杂度和算法该如何选择：
1234567891011n≤30, 指数级别, dfs+剪枝，状态压缩dpn≤100 =&gt; O(n3)，floyd，dp，高斯消元n≤..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    算法Algorithm |
    
    Kevin&#39;s Blog
</title>

<link rel="alternate" href="/atom.xml" title="Kevin&#39;s Blog" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.1.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.4pvt8z0ci5y0.webp)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Kevin'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://example.com">
                        Kevin&#39;s Blog</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/CS基础/"><i class="fa "></i>
                                CS基础</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/语言学习/"><i class="fa "></i>
                                语言学习</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/杂谈/"><i class="fa "></i>
                                杂谈</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="算法Algorithm">
            
            算法Algorithm
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/CS%E5%9F%BA%E7%A1%80/">CS基础</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2022/04/19</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <p>不同数据范围下，代码的时间复杂度和算法该如何选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n≤30, 指数级别, dfs+剪枝，状态压缩dp</span><br><span class="line">n≤100 =&gt; O(n3)，floyd，dp，高斯消元</span><br><span class="line">n≤1000 =&gt; O(n2)，O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</span><br><span class="line">n≤10000 =&gt; O(n∗n√)，块状链表、分块、莫队</span><br><span class="line">n≤100000 =&gt; O(nlogn) =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</span><br><span class="line">n≤1000000 =&gt; O(n), 以及常数较小的 O(nlogn)O(nlogn) 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa</span><br><span class="line">n≤10000000 =&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数</span><br><span class="line">n≤109 =&gt; O(n√)，判断质数</span><br><span class="line">n≤1018 =&gt; O(logn)，最大公约数，快速幂，数位DP</span><br><span class="line">n≤101000 =&gt; O((logn)2)，高精度加减乘除</span><br><span class="line">n≤10100000 =&gt; O(logk×loglogk)，k表示位数，高精度加减、FFT/NTT</span><br></pre></td></tr></table></figure>

<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p> 在数组中选中一个坐标位置，将数组中比它大的数移动到其右边，比它小的移动到它的左边，然后通过递归的形式对其左右排序过一次的部分进行再次排序，直到左坐标与右坐标重合。</p>
<h4 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h4><p> 在数组中确定一个具体的坐标比对数，便于对左右两侧的数进行比对，同时注意数组的Index_Out_Of_Bounds下标越界问题</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>Java的快速排序写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> private static void quickSort(int[] arr, int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right) return;</span><br><span class="line">   int x = arr[left + right &gt;&gt; 1], i = left - 1, j = right + 1;</span><br><span class="line">   while (i &lt; j) &#123;</span><br><span class="line">        do i++; while (arr[i] &lt; x);</span><br><span class="line">        do j--; while (arr[j] &gt; x);</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort(arr, left, j);</span><br><span class="line">    quickSort(arr, j + 1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++的快速排序写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void quicksort(int a[],int head,int tail)</span><br><span class="line">&#123;</span><br><span class="line">    if(head&gt;=tail) return;</span><br><span class="line">    int i=head-1,j=tail+1;//确定左右坐标</span><br><span class="line">    int pivot=a[head+tail&gt;&gt;1];//确定比对基准数</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i++;while(a[i]&lt;pivot);//从左开始，若当前数比基准数小，则坐标继续向右移动</span><br><span class="line">        do j--;while(a[j]&gt;pivot);//从右开始，若当前数比基准数大，则坐标继续向左移动</span><br><span class="line">        if(i&lt;j)//检测左右坐标是否符合条件</span><br><span class="line">        &#123;//交换两坐标所在的数</span><br><span class="line">            int temp=a[i];</span><br><span class="line">            a[i]=a[j];</span><br><span class="line">            a[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quicksort(a,head,j);//递归处理前半部分</span><br><span class="line">    quicksort(a,j+1,tail);//递归处理后半部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓展题目"><a href="#拓展题目" class="headerlink" title="拓展题目"></a>拓展题目</h4><p>第k个数:<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/820/">https://www.acwing.com/activity/content/problem/content/820/</a></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p> 将排序的整个问题分为一个个小数组的排序问题，通过从一个个局部入手解决局部的排序问题实现对整个大数组的排序，解决一个个小问题，逐步攻克解决整个的问题。</p>
<h4 id="Emphasis-1"><a href="#Emphasis-1" class="headerlink" title="Emphasis"></a>Emphasis</h4><p> 1.从局部到全局的问题解决思路</p>
<p> 2.双比对点对数组的遍历以及比较</p>
<p> 3.中介数组的数据存放</p>
<p> 4.中介数组复制给原数组</p>
<p> 5.两个比对点分别到达其极限后需检查另一比对点是否到达极限</p>
<p> 6.中介数组复制到原数组时，原数组应该从L坐标开始向后遍历而不是0或1</p>
<h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void merge_sort(int q[],int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    if(l&gt;=r) return;//无法进行的判断</span><br><span class="line">    int mid=l+r&gt;&gt;1;//确定局部解决问题的点</span><br><span class="line">    merge_sort(q,l,mid);//对前半局部进行排序</span><br><span class="line">    merge_sort(q,mid+1,r);//对后半局部进行排序</span><br><span class="line">    </span><br><span class="line">    int k=0;//tmp数组录入和取出的使用坐标</span><br><span class="line">    int i=l;//原数组的第一比对起点</span><br><span class="line">    int j=mid+1;//原数组的第二比对起点</span><br><span class="line">    int tmp[r-l+1];//中介数组，将原数组中排序好的数据进行存储</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;//下标越界处理</span><br><span class="line">        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];//第一比对点小于第二比对点，则第一比对点向后移动，第二比对点不动，且中介数组tmp中存储第一比对点对应的数</span><br><span class="line">        else tmp[k++]=q[j++];//否则存储第二比对点所对应的数</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=mid) tmp[k++]=q[i++];//当第二比对点到达其下标极限时，直接把前半部分的数存入中介数组中</span><br><span class="line">    while(j&lt;=r) tmp[k++]=q[j++];//当第一比对点到达其下表极限时，直接把后半部分存入中介数组中</span><br><span class="line">    for(k=0,i=l;i&lt;=r;i++,k++) q[i]=tmp[k];//将tmp数组中已经全部排序好的数重新录入到原数组中，完成排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓展题目-1"><a href="#拓展题目-1" class="headerlink" title="拓展题目"></a>拓展题目</h4><p>逆序对的数量:<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/822/">https://www.acwing.com/activity/content/problem/content/822/</a></p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p> 通过两个分别指向头部和尾部的指针，对一个<strong>有序</strong>数组中的元素进行查找，每一次检查两个指针的中间位置的数，分别作出如下判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int numbers[];</span><br><span class="line">int left=0</span><br><span class="line">int right=numbers.size()-1;</span><br><span class="line">while(left&lt;=right)&#123;</span><br><span class="line">if(numbers[mid]==target) return mid;</span><br><span class="line">if(numbers[mid]&lt;target) left=mid;</span><br><span class="line">if(numbers[mid]&gt;target) right=mid;</span><br><span class="line">&#125;//二分查找的基本思想</span><br></pre></td></tr></table></figure>

<h3 id="Emphasis-2"><a href="#Emphasis-2" class="headerlink" title="Emphasis"></a>Emphasis</h3><p> 1.左右指针</p>
<p> 2.中央指针</p>
<p> 3.左右指针的越界判断</p>
<h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int numbers[100010];//查找数组</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;//数组元素个数</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int q;//查询次数</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;numbers[i];</span><br><span class="line">    &#125;//输入数据</span><br><span class="line">    while(q--&gt;0)&#123;//查询</span><br><span class="line">        int target;//查询数字</span><br><span class="line">        cin&gt;&gt;target;</span><br><span class="line">        int l=0,r=n-1;</span><br><span class="line">        while(l&lt;r)//边界判断</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=l+r&gt;&gt;1;//中间指针</span><br><span class="line">            if(numbers[mid]&gt;=target) r=mid;</span><br><span class="line">            else l=mid+1;</span><br><span class="line">        &#125;//此方法以大于等于目标数为判断条件，所以会得出第一次出现的目标数的坐标</span><br><span class="line">        int left=l;</span><br><span class="line">        if(numbers[l]!=target) cout&lt;&lt;-1&lt;&lt;&quot; &quot;&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">        else&#123;</span><br><span class="line">            l=0;</span><br><span class="line">            r=n-1;</span><br><span class="line">            while(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                int mid=l+r+1&gt;&gt;1;</span><br><span class="line">                if(numbers[mid]&lt;=target) l=mid;</span><br><span class="line">                else r=mid-1;</span><br><span class="line">            &#125;//此方法以小于等于坐标数为判断条件，所以会得出最后一次出现的目标数的坐标</span><br><span class="line">            cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">        &#125;//综述，其实就是两次二分查找，通过对于查找方式的改变，得到第一次出现和第二次出现的坐标</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目-2"><a href="#拓展题目-2" class="headerlink" title="拓展题目"></a>拓展题目</h3><p>数的三次方根:<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/824/">https://www.acwing.com/activity/content/problem/content/824/</a></p>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p> 前缀和的基本思路在于用一个额外的数组，sums[i]存储原数组第一个数一直到第i个数的和，其中数组遍历不再从0下标开始，为了直观直接从1下标开始，同时也更好理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//一段数组，假设为&#123;a1,a2,a3,a4,a5&#125;</span><br><span class="line">//则设sums[6]，通过前缀和处理之后sums中的元素为</span><br><span class="line">numebers[6]=&#123;0,a1,a2,a3,a4,a5&#125;</span><br><span class="line">sums[6]=&#123;0,a1,a1+a2,a1+a2+a3,a1+..+a4,a1+...+a5&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Emphasis-3"><a href="#Emphasis-3" class="headerlink" title="Emphasis"></a>Emphasis</h3><p> 1.前缀和数组的构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sums[i]=sums[i-1]+numbers[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 2.原数组和前缀和数组的下标都是从1开始，既方便理解，也能更直观的调用</p>
<p> 3.当需要得到l-r数字的和时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标段落数据和==sums[r]-sums[l-1]</span><br></pre></td></tr></table></figure>

<h3 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int numbers[100010];</span><br><span class="line">int sums[100010];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sums[i]=sums[i-1]+numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(m--&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l;</span><br><span class="line">        cin&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt;sums[r]-sums[l-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目-3"><a href="#拓展题目-3" class="headerlink" title="拓展题目"></a>拓展题目</h3><p> 子矩阵的和：<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/830/">https://www.acwing.com/activity/content/problem/content/830/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</span><br><span class="line"></span><br><span class="line">对于每个询问输出子矩阵中所有数的和。</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const  int N=1010;</span><br><span class="line"></span><br><span class="line">int numbers[N][N];//原数组</span><br><span class="line">int sums[N][N];//前缀和数组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int n,m,q;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;numbers[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n;i++)//前缀和数组构造</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sums[i][j]=sums[i][j-1]+sums[i-1][j]+numbers[i][j]-sums[i-1][j-1];</span><br><span class="line">        &#125;//其中前缀和构造下标的处理需要注意，总体来说是目标坐标的数+上方所有的和+下方所有的和-重复的左上角所有数的和</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(q--&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        int x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1;</span><br><span class="line">        cin&gt;&gt;y1;</span><br><span class="line">        cin&gt;&gt;x2;</span><br><span class="line">        cin&gt;&gt;y2;</span><br><span class="line">        cout&lt;&lt;sums[x2][y2]+sums[x1-1][y1-1]-sums[x2][y1-1]-sums[x1-1][y2]&lt;&lt;endl;//此处下标同样需要注意</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">差分作为由前缀和衍生出来的算法思想，具有对某一区间或者某一范围的对象进行集体操作的特性，在对于批量对象进行操作时可以使用</span><br><span class="line"></span><br><span class="line">其中，差分数组中的每个元素对应着原数组每个元素相应位置减去前一个数的差，例：</span><br><span class="line">int nums[3]=&#123;a1,a2,a3&#125;;</span><br><span class="line">int dif[3]=&#123;a1-0,a2-a1,a3-a2&#125;;</span><br><span class="line">同时差分数组也需要注意下标的起始</span><br></pre></td></tr></table></figure>

<p> 差分：<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/831/">https://www.acwing.com/activity/content/problem/content/831/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int numbers[100010];//原数组</span><br><span class="line">int dif[100010];//差分数组</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,l,r,c;</span><br><span class="line">    cin&gt;&gt;n;//输入数字个数</span><br><span class="line">    cin&gt;&gt;m;//操作数</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dif[i]=numbers[i]-numbers[i-1];//差分数组构造</span><br><span class="line">    &#125;</span><br><span class="line">    while(m--&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;l;//左起始坐标</span><br><span class="line">        cin&gt;&gt;r;//右结束坐标</span><br><span class="line">        cin&gt;&gt;c;//操作同时加起来的数</span><br><span class="line">        dif[l]+=c;</span><br><span class="line">        dif[r+1]-=c;//下标需要注意</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dif[i]+=dif[i-1];//差分数组的重新组合成目标得到的数组</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;dif[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 差分矩阵：<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/832/">https://www.acwing.com/activity/content/problem/content/832/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">差分矩阵的构造，实际上就是让原矩阵成为差分矩阵的前缀和数组</span><br><span class="line">dif[x1][y1]+=c;//此操作相当于对以(x1,y1)为左上角直到矩阵最右下角的所有数进行+c操作</span><br><span class="line">dif[x2+1][y1]-=c;//目标区域的右侧需要减去c</span><br><span class="line">dif[x1][y2+1]-=c;//目标区域的下侧需要减去c</span><br><span class="line">dif[x2+1][y2+1]+=c;//(x2,y2)一直到矩阵右下角的所有数加上重复减去的c</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dif[i][j]+=mat[i][j];</span><br><span class="line">            dif[i+1][j]-=mat[i][j];</span><br><span class="line">            dif[i][j+1]-=mat[i][j];</span><br><span class="line">            dif[i+1][j+1]+=mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//差分矩阵的构造</span><br></pre></td></tr></table></figure>

<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p> 双指针算法在具体实现过程中，可分为朴素做法以及快捷做法：</p>
<p> 其中朴素做法的时间复杂度为O(N^2)，具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;//跑的快的指针</span><br><span class="line">	for(int j=0;j&lt;=i;j++)</span><br><span class="line">    &#123;//跑的慢一点的指针</span><br><span class="line">        if(check(j,i))//check函数为具体判断子串是否有重复的逻辑函数</span><br><span class="line">        &#123;</span><br><span class="line">            res=max(res,j-i+1);//res即可得到最长的不重复连续子串长度</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Emphasis-4"><a href="#Emphasis-4" class="headerlink" title="Emphasis"></a>Emphasis</h3><p>双指针有两种具体实现：</p>
<p>1.快慢指针：以一个数组为例，一个指针为慢指针，每次向后遍历一个元素，一个指针为快指针，每次向后遍历两个元素，如此便是快慢指针。</p>
<p>2.对撞指针：同样以数组为例，一个指针设置在数组的头元素，一个指针设置在数组的末尾，两个指针同时向中间移动，直至对撞相遇</p>
<hr>
<p>在不同的情况下，需要根据实际情况和题目需求确认双指针的具体应用类型：</p>
<p>1.单一序列中的元素操作</p>
<p>2.多个序列中的元素对比</p>
<h3 id="具体实现-4"><a href="#具体实现-4" class="headerlink" title="具体实现"></a>具体实现</h3><p>例题：给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<p>输入格式</p>
<p>第一行包含整数 nn。</p>
<p>第二行包含 nn 个整数（均在 0∼1050∼105 范围内），表示整数序列。</p>
<p>输出格式</p>
<p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<p>数据范围</p>
<p>1≤n≤10^5</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>题解</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p> 数组边输入就边进行记录数组中元素的次数，输入与记录重复数字同时进行，节省了朴素算法中需要全部输入之后重新遍历的浪费时间的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;//数组预留长度</span><br><span class="line">int a[N];//实际数组</span><br><span class="line">int s[N];//用于存储数组中每个元素出现次数的数组</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,r=0;</span><br><span class="line">    cin&gt;&gt;n;//数组长度</span><br><span class="line">    </span><br><span class="line">    for(int i=0，j=0;i&lt;n;++i)//指针i很明显是用于数组输入的坐标</span><br><span class="line">    &#123;//指针j则是作为判断，一旦有数字出现了两次，一直将j指针迁移到当前重复的数字坐标上，同时r保留之前片段的最长不重复子段长度</span><br><span class="line">        cin&gt;&gt;a[i];//每一次操作，先输入</span><br><span class="line">        ++ s[a[i]];</span><br><span class="line">        while(s[a[i]]&gt;1) --s[a[j++]];</span><br><span class="line">        r=max(r,i-j+1);//j指针类似于一个同步判定指针，和i指针具有协同作用，并非传统意义上的快慢指针或者对撞指针</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/A8CF07178F5EF5C953DCBDA82CC53EF4.7bt2dzqvsos0.webp" alt="A8CF07178F5EF5C953DCBDA82CC53EF4"></p>
<h3 id="拓展题目-4"><a href="#拓展题目-4" class="headerlink" title="拓展题目"></a>拓展题目</h3><p> 数组元素的目标和：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/802/">https://www.acwing.com/problem/content/802/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line">int A[N];//A数组</span><br><span class="line">int B[N];//B数组</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0,j=m-1;i&lt;n;i++)//i指针从A数组从前向后遍历，j指针从B数组从后往前遍历</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&gt;=0&amp;&amp;A[i]+B[j]&gt;x) j--;//普通的条件判断</span><br><span class="line">        if(j&gt;=0&amp;&amp;A[i]+B[j]==x) cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 判断子序列：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2818/">https://www.acwing.com/problem/content/2818/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e5+10;</span><br><span class="line">int a[N],b[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int j=0;j&lt;m;j++) cin&gt;&gt;b[j];</span><br><span class="line">    </span><br><span class="line">    int i=0;</span><br><span class="line">    for(int j=0;j&lt;m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i&lt;n&amp;&amp;a[i]==b[j]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==n) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">    else cout&lt;&lt;&quot;No&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h3><p> 首先，位运算中具备以下几大原则</p>
<hr>
<p>1.按位与 &amp;</p>
<p> 两个相应的二进制位都为1，则该位的结果为1，否则为0</p>
<p>2.按位或 |</p>
<p> 两个相应的二进制位只要有一个为1，则结果为1</p>
<p>3.按位异或 ^</p>
<p> 两个二进制位值相同则为0，否则为1</p>
<p>4.取反 ~</p>
<p> 对一个二进制数进行取反，使其位上0变为1，1变为0</p>
<p>5.左移 &lt;&lt;</p>
<p> 将一个数的二进制位全部左移N位，右补0</p>
<p>6.右移 &gt;&gt;</p>
<p> 将一个数的二进制位右移N位，移到右端的低位被舍弃</p>
<h3 id="Emphasis-5"><a href="#Emphasis-5" class="headerlink" title="Emphasis"></a>Emphasis</h3><h3 id="具体实现-5"><a href="#具体实现-5" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    while (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        int number;</span><br><span class="line">        int count=0;</span><br><span class="line">        cin&gt;&gt;number;</span><br><span class="line">        while(number&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            number=number&amp;(number-1);//核心代码，相当于每一次从当前最低位将一个1在下一次变换中变为0，以此类推，因为如果减一的话，相当于把后面倒数第一个1变为0</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;count&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目-5"><a href="#拓展题目-5" class="headerlink" title="拓展题目"></a>拓展题目</h3><p>二进制中1的个数:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/803/">https://www.acwing.com/problem/content/803/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//求二进制数中1的个数</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int hammingWeight(int n) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; i++) &#123;</span><br><span class="line">            if ((n &amp; (1 &lt;&lt; i)) != 0) &#123;//左移一位等价于乘以2</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//技巧:n&amp;(n-1)操作可以消除二进制数中的最后一个1</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目2"><a href="#拓展题目2" class="headerlink" title="拓展题目2:"></a>拓展题目2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</span><br><span class="line">//如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPowerOfTwo(int n) &#123;</span><br><span class="line">        return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h3 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h3><p> 离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。</p>
<p> 通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：</p>
<p> 原数据：1,999,100000,15；处理后：1,3,4,2；</p>
<p> 原数据：{100,200}，{20,50000}，{1,400}；</p>
<p> 处理后：{3,4}，{2,6}，{1,5}；</p>
<h3 id="Emphasis-6"><a href="#Emphasis-6" class="headerlink" title="Emphasis"></a>Emphasis</h3><p> 离散化的基本思路是，先排序，再删除重复元素，最后就是索引元素离散化后对应的值</p>
<p><img src="https://cdn.acwing.com/media/article/image/2019/11/11/13021_4a9746ee04-%E5%8C%BA%E9%97%B4%E5%92%8C%E9%A2%98%E8%A7%A3.png" alt="区间和题解.png"></p>
<p>在离散化做法中，没有必要按照规定的顺序，将对应的操作插入到相应的位置中，只需要利用好其相对位置的关系，就可以节省大量的空间以及时间，</p>
<p> “相对位置”这个概念非常重要</p>
<h3 id="具体实现-6"><a href="#具体实现-6" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p>
<p>现在，我们首先进行 nn次操作，每次操作将某一位置 x 上的数加 c。</p>
<p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r][l,r] 之间的所有数的和。</p>
<p>输入格式</p>
<p>第一行包含两个整数 n 和 m。</p>
<p>接下来 n 行，每行包含两个整数 x 和 c。</p>
<p>再接下来 m 行，每行包含两个整数 l 和 r。</p>
<p>输出格式</p>
<p>共 m 行，每行输出一个询问中所求的区间内数字和。</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line"></span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">//基本头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;//定义PII数对</span><br><span class="line"></span><br><span class="line">const int N = 300010;</span><br><span class="line"></span><br><span class="line">int n,m;//n为操作次数，m为查询次数</span><br><span class="line">int a[N],s[N];//数组a[N]是原数串,s[N]是前缀和处理数组</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; alls;//alls存储与操作相关的所有坐标</span><br><span class="line">vector&lt;PII&gt; add,query;</span><br><span class="line"></span><br><span class="line">int find(int x) </span><br><span class="line">&#123;//find函数用于在alls容器中找到对应的坐标</span><br><span class="line">    int l=0,r=alls.size()-1;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(alls[mid]&gt;=x) r=mid;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;//此处add容器作用是存储相应坐标上加减的数，alls容器的作用是存储有过操作的坐标</span><br><span class="line">        int x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.push_back(&#123;x,c&#125;);</span><br><span class="line">        </span><br><span class="line">        alls.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;//query容器的作用很明显是作为存放查询左端和右端坐标的数对容器</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.push_back(&#123;l,r&#125;);</span><br><span class="line">        </span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //去重</span><br><span class="line">    sort(alls.begin(),alls.end());//对alls进行排序</span><br><span class="line">    alls.erase(unique(alls.begin(),alls.end()),alls.end());//对alls中的元素进行去重</span><br><span class="line">    </span><br><span class="line">    //处理插入</span><br><span class="line">    for(auto item:add)</span><br><span class="line">    &#123;</span><br><span class="line">        int x=find(item.first);</span><br><span class="line">        a[x]+=item.second;</span><br><span class="line">    &#125;//将add数对容器中的数对提取出来，进行对数串上的操作</span><br><span class="line">    </span><br><span class="line">    //预处理前缀和</span><br><span class="line">    for(int i=1;i&lt;=alls.size();i++) s[i]=s[i-1]+a[i];</span><br><span class="line">    </span><br><span class="line">    //处理询问</span><br><span class="line">    for(auto item:query)//query中每个元素都是数对</span><br><span class="line">    &#123;</span><br><span class="line">        int l=find(item.first),r=find(item.second);</span><br><span class="line">        cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">在上述代码中，一共用到了三个容器，分别是</span><br><span class="line">1.整型数据容器alls</span><br><span class="line">	作用：存储与操作相关的所有坐标</span><br><span class="line">2.整型数对容器add</span><br><span class="line">	作用：存储对数串上每个坐标的操作详细，存储每个点坐标和对点坐标上加减的数对</span><br><span class="line">3.整型数对容器query</span><br><span class="line">	作用：存储每一次查询的数串区间</span><br></pre></td></tr></table></figure>

<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><h3 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h3><hr>
<p>1.按区间左端点进行排序</p>
<p>2.通过比对右端点产生的不同情况进行不同的操作</p>
<p> 三种情况：<img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image-20220211200103664.307g63pmqew0.jpg" alt="image-20220211200103664"></p>
<p>绿色情况：用原区间覆盖，即不变</p>
<p>橙色情况：延长ed的长度</p>
<p>粉色情况：无交集，当前比较区间就可以独立出来了</p>
<h3 id="Emphasis-7"><a href="#Emphasis-7" class="headerlink" title="Emphasis"></a>Emphasis</h3><hr>
<p>注意题目给出的端点判断依据即可</p>
<h3 id="具体实现-7"><a href="#具体实现-7" class="headerlink" title="具体实现"></a>具体实现</h3><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;//数对，用于存放输入的每一个区间</span><br><span class="line"></span><br><span class="line">vector&lt;PII&gt; segs;//区间的存储容器</span><br><span class="line"></span><br><span class="line">void merge(vector&lt;PII&gt; &amp;segs)//区间的合并函数</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;PII&gt; res;//返回的答案区间</span><br><span class="line">    </span><br><span class="line">    sort(segs.begin(),segs.end());//先对原区间以每个数对的第一个数为基准进行排序</span><br><span class="line">    </span><br><span class="line">    int st=-2e9,ed=-2e9;//设置边界</span><br><span class="line">    for(auto seg:segs)//对每一个小区间进行单独判断以及操作</span><br><span class="line">    &#123;</span><br><span class="line">        if(ed&lt;seg.first)</span><br><span class="line">        &#123;//具体的逻辑实现</span><br><span class="line">            if(st!=-2e9) res.push_back(&#123;st,ed&#125;);</span><br><span class="line">            st=seg.first,ed=seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        else ed=max(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(st!=-2e9) res.push_back(&#123;st,ed&#125;);</span><br><span class="line">    </span><br><span class="line">    segs=res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        cin&gt;&gt;l;</span><br><span class="line">        cin&gt;&gt;r;</span><br><span class="line">        segs.push_back(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    merge(segs);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;segs.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><hr>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="结构特征"><a href="#结构特征" class="headerlink" title="结构特征"></a>结构特征</h3><p>单链表是由一个个链表节点构成的一个整体，其中每个结点具有其权值和指向后一结点的指针，此处以数组的形式模拟链表</p>
<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image-20220213122926194.png" alt="image-20220213122926194"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int val;//权值</span><br><span class="line">    Node *next;//指向下一结点的指针</span><br><span class="line">&#125;//单一结点的定义</span><br><span class="line"></span><br><span class="line">new node();//非常慢</span><br><span class="line"></span><br><span class="line">//在实际工程和算法题目中，一般不采用动态列表以及以new方法创建结点的方式构造链表，其速度太慢，适用面很窄</span><br></pre></td></tr></table></figure>

<p>普通的插入函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//Declare Node</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int num;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line">//Declare starting (Head) node</span><br><span class="line">struct Node *head=NULL;</span><br><span class="line">//Insert node at start</span><br><span class="line">void insertNode(int n)&#123;</span><br><span class="line">    struct Node *newNode=new Node;</span><br><span class="line">    newNode-&gt;num=n;</span><br><span class="line">    newNode-&gt;next=head;</span><br><span class="line">    head=newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image-20220213122110536.png" alt="image-20220213122110536"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="数组版本"><a href="#数组版本" class="headerlink" title="数组版本"></a>数组版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line">//head表示头结点的下标</span><br><span class="line">//e[i]表示节点i的值</span><br><span class="line">//ne[i]表示结点i的next指针是多少</span><br><span class="line">//idx存储当前已经用到了哪个点</span><br><span class="line">int idx,head,e[N],ne[N];</span><br><span class="line">int a;</span><br><span class="line">void add_head(int x)&#123;//头结点插入</span><br><span class="line">    e[idx]=x;//先将最新结点赋值</span><br><span class="line">    ne[idx]=head;//将idx结点的指针进行对应的操作</span><br><span class="line">    head=idx++;//idx向后移动一位，head也向后移动一位</span><br><span class="line">&#125;</span><br><span class="line">void add(int k,int x)&#123;//k结点之后插入</span><br><span class="line">    e[idx]=x;//先对最新点赋值</span><br><span class="line">    ne[idx]=ne[k];//改变新结点指针的指向</span><br><span class="line">    ne[k]=idx++;//前一个结点的next指针重新指向新结点</span><br><span class="line">&#125;</span><br><span class="line">void remove(int k)&#123;//删除第k个结点</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    head=-1;idx=0;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    while(a--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        int k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        if(op==&quot;D&quot;)//删除第k个数后面的数</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            if(!k)head=ne[head];</span><br><span class="line">            remove(k-1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;H&quot;)//表头插入</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            add_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;I&quot;)&#123;//指定位置插入</span><br><span class="line">            int k,x;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k-1,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=head;i!=-1;i=ne[i])</span><br><span class="line">      cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//此处采用的是用数组模拟单链表的方式</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/CCF282EEFE571D40F6829209498ECD7B.4chxgryuq1u0.jpg" alt="CCF282EEFE571D40F6829209498ECD7B"></p>
<h4 id="指针版本"><a href="#指针版本" class="headerlink" title="指针版本"></a>指针版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line"></span><br><span class="line">private://私人函数定义</span><br><span class="line">    int size;//表示链表长度</span><br><span class="line">    node *head;//定义头指针</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct node&#123;//单链表节点结构</span><br><span class="line">        int val;//数据域</span><br><span class="line">        node *next;//指针域</span><br><span class="line">        node(int x): val(x),next(NULL)&#123;&#125;//表示的含义就是节点数值为x，指针为空（初始化一个新节点）</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    MyLinkedList() &#123;//初始化链表</span><br><span class="line">        head=new node(0);</span><br><span class="line">        size=0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int index) &#123;//获取索引节点数值</span><br><span class="line">        if(index&lt;0||index&gt;(size-1)) return -1;//索引比0小或者比最大索引大，返回-1</span><br><span class="line">        node *cur=head-&gt;next;//辅助指针指向第一个节点</span><br><span class="line">        while(index--) cur=cur-&gt;next;//循环index次遍历到第index个节点</span><br><span class="line">        return cur-&gt;val;//指向数值输出</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtHead(int val) &#123;//插入头</span><br><span class="line">        node *newnode=new node(val);//创建新节点</span><br><span class="line">        newnode-&gt;next=head-&gt;next;//将头节点的next赋值给新的节点---&gt;相当于连接新插入节点与第一个节点</span><br><span class="line">        head-&gt;next=newnode;//连接头指针与第一个新节点</span><br><span class="line">        size++;//长度加1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtTail(int val) &#123;//插入尾</span><br><span class="line">        node *cur=head;//辅助指针从头指针开始</span><br><span class="line">        while(cur-&gt;next) cur=cur-&gt;next;//遍历到最后一个节点,如果是空链表，则直接不循环，指针还是在头指针</span><br><span class="line">        node *newnode=new node(val);//创造新节点并赋值</span><br><span class="line">        newnode-&gt;next=cur-&gt;next;//复制原最后节点的next信息</span><br><span class="line">        cur-&gt;next=newnode;//连接最后一个新节点和上一个节点</span><br><span class="line">        size++;//长度加1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        if(index&lt;=0) addAtHead(val);//插入index的时候，如果下标是=0,就相当于从头插入，所以要包含&lt;=</span><br><span class="line">        else if(index==size) addAtTail(val);</span><br><span class="line">        else if(index&gt;size) return ;</span><br><span class="line">        else&#123;</span><br><span class="line">            node *newnode=new node(val);</span><br><span class="line">            node *cur=head;//辅助指针从头指针开始</span><br><span class="line">            while(index--) cur=cur-&gt;next;</span><br><span class="line">            newnode-&gt;next=cur-&gt;next;//连接index</span><br><span class="line">            cur-&gt;next=newnode;//连接前一个</span><br><span class="line">            size++;//长度+1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void deleteAtIndex(int index) &#123;</span><br><span class="line">        if(index&lt;0||index&gt;=size) return ;</span><br><span class="line">        node *cur=head;//从头指针开始</span><br><span class="line">        while(index--)&#123;//遍历到index-1的位置,循环次数是index次</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;//相当于直接跨过了index节点</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="结构特征-1"><a href="#结构特征-1" class="headerlink" title="结构特征"></a>结构特征</h3><p> 双链表不同于单链表，其中每一个结点除了指向下一结点的指针以外，还具有指向前一结点的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">    int val;//权值</span><br><span class="line">    Node *pre;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="数组版本-1"><a href="#数组版本-1" class="headerlink" title="数组版本"></a>数组版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int e[N],l[N],r[N],idx;//l[N]存储左结点指针，r[N]存储右结点指针</span><br><span class="line"></span><br><span class="line">void init()//初始化</span><br><span class="line">&#123;</span><br><span class="line">    r[0]=1,l[1]=0;//最初的两个点进行初始化处理</span><br><span class="line">    idx=2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int k,int x)//在第k个结点的右边插入权值为x的结点</span><br><span class="line">&#123;</span><br><span class="line">    e[idx]=x;//权值赋值</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    l[r[k]]=idx;</span><br><span class="line">    r[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int k)//删除第k个结点</span><br><span class="line">&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    while (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        int k,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        </span><br><span class="line">        if(op==&quot;L&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            add(0,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;R&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            add(l[1],x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;D&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            remove(k+1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;IL&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(l[k+1],x);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k+1,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=r[0];i!=1;i=r[i]) cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针版本-1"><a href="#指针版本-1" class="headerlink" title="指针版本"></a>指针版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line">struct ListNode</span><br><span class="line">&#123;//结点定义</span><br><span class="line">    int val;//权值</span><br><span class="line">    ListNode* prev;//前驱指针</span><br><span class="line">    ListNode* next;//后驱指针</span><br><span class="line">    ListNode(int x):val(x),prev(this),next(this)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    MyLinkedList() &#123;//创建函数</span><br><span class="line">        head = new ListNode(-1);</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    int get(int index) &#123;//查找函数</span><br><span class="line">        ListNode* pos =head;//先安排一个结点从头开始</span><br><span class="line">        while(index--&gt;=0)&#123;//向后遍历</span><br><span class="line">            pos=pos-&gt;next;</span><br><span class="line">            if(pos==head) //如果就一个结点，直接返回权值</span><br><span class="line">                return head-&gt;val;</span><br><span class="line">        &#125; </span><br><span class="line">        return pos-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    void addAtHead(int val) &#123;//头插</span><br><span class="line">        ListNode* node =new ListNode(val);//先建立一个新结点并赋值</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        node-&gt;next-&gt;prev=node;</span><br><span class="line">        node-&gt;prev=head;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void addAtTail(int val) &#123;//尾插</span><br><span class="line">        ListNode* node =new ListNode(val);</span><br><span class="line">        node-&gt;prev = head-&gt;prev;</span><br><span class="line">        head-&gt;prev = node;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">        node-&gt;next = head;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void addAtIndex(int index, int val) &#123;</span><br><span class="line">        ListNode* pos = head;</span><br><span class="line">        if(index==size)</span><br><span class="line">        &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            //定位到插入位置</span><br><span class="line">        while(index--&gt;=0)&#123;</span><br><span class="line">            pos=pos-&gt;next;</span><br><span class="line">            if(pos==head) </span><br><span class="line">            &#123;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* node = new ListNode(val);</span><br><span class="line">        node-&gt;prev = pos-&gt;prev;</span><br><span class="line">        pos-&gt;prev = node;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">        node-&gt;next = pos;</span><br><span class="line">        size++;</span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    void deleteAtIndex(int index) &#123;//删除结点</span><br><span class="line">        ListNode* pos = head;</span><br><span class="line">        while(index--&gt;=0)&#123;</span><br><span class="line">            pos=pos-&gt;next;</span><br><span class="line">            if(pos==head) </span><br><span class="line">                return ;            </span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = pos-&gt;next;</span><br><span class="line">        pos-&gt;next-&gt;prev =pos-&gt;prev;</span><br><span class="line">        pos-&gt;prev-&gt;next = temp;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int size;</span><br><span class="line">    ListNode* head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="结构特征-2"><a href="#结构特征-2" class="headerlink" title="结构特征"></a>结构特征</h3><p> 在数据结构栈中，可以用FILO即first in last out即先进后出概括其特点，最先进入栈中的元素在执行出栈操作时，反而最后出栈，就好像抽纸，最先放入的那张纸反而最后才会抽出来</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">int stack[N];</span><br><span class="line">int idx=-1;</span><br><span class="line"></span><br><span class="line">void push(int x)//压栈</span><br><span class="line">&#123;</span><br><span class="line">    stack[++idx]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void empty()//空栈判断</span><br><span class="line">&#123;</span><br><span class="line">    if(idx&gt;=0) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pop()</span><br><span class="line">&#123;</span><br><span class="line">    idx--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void query()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;stack[idx]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int M;</span><br><span class="line">    string op;</span><br><span class="line">    while (M -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        if(op==&quot;push&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            int x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;pop&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;empty&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            empty();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op==&quot;query&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            query();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h3><p> 表达式求值：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3305/">https://www.acwing.com/problem/content/3305/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; nums;//数值栈</span><br><span class="line">stack&lt;char&gt; op;//操作符栈</span><br><span class="line"></span><br><span class="line">unordered_map&lt;int,char&gt; h&#123;&#123;&#x27;+&#x27;, 1&#125;, &#123;&#x27;-&#x27;, 1&#125;, &#123;&#x27;*&#x27;,2&#125;, &#123;&#x27;/&#x27;, 2&#125;&#125;;//优先级对应表</span><br><span class="line"></span><br><span class="line">void eval()</span><br><span class="line">&#123;</span><br><span class="line">    int a=nums.top();</span><br><span class="line">    nums.pop();</span><br><span class="line">    int b=nums.top();</span><br><span class="line">    nums.pop();//取出数值栈中的两个数</span><br><span class="line">    </span><br><span class="line">    char opr=op.top();</span><br><span class="line">    op.pop();</span><br><span class="line">    </span><br><span class="line">    int r=0;</span><br><span class="line">    if(opr==&#x27;+&#x27;) r=a+b;</span><br><span class="line">    if(opr==&#x27;-&#x27;) r=a-b;</span><br><span class="line">    if(opr==&#x27;*&#x27;) r=a*b;</span><br><span class="line">    if(opr==&#x27;/&#x27;) r=a/b;</span><br><span class="line">    </span><br><span class="line">    nums.push(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string exp;</span><br><span class="line">    cin&gt;&gt;exp;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;exp.size();i++)&#123;</span><br><span class="line">        if(isdigit(exp[i]))&#123;</span><br><span class="line">            int x=0,j=i;</span><br><span class="line">            while(j&lt;exp.size()&amp;&amp;isdigit(exp[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                x=x*10+exp[j]-&#x27;0&#x27;;</span><br><span class="line">                j++;//因为计算中不可能只有一位数，比如12，但是遍历的时候是一个一个字符遍历的，所以对于连续的多位数字，我们需要采取能够保留完整计算数的方法</span><br><span class="line">            &#125;</span><br><span class="line">            nums.push(x);</span><br><span class="line">            i=j-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(exp[i]==&#x27;(&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            op.push(exp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(exp[i]==&#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            while(op.top()!=&#x27;(&#x27;)</span><br><span class="line">                eval();</span><br><span class="line">            op.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            while(op.size()&amp;&amp;h[op.top()]&gt;=h[exp[i]])</span><br><span class="line">                eval();</span><br><span class="line">            op.push(exp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(op.size()) eval();</span><br><span class="line">    cout&lt;&lt;nums.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 单调栈：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/832/">https://www.acwing.com/problem/content/832/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int stck[N];//操作栈</span><br><span class="line">int top=0;//栈顶坐标</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        while(top&amp;&amp;stck[top]&gt;=x) top--;//栈不为空且栈顶元素大于即将入栈元素时，</span><br><span class="line">        if(!top) cout&lt;&lt;&quot;-1 &quot;;//一旦栈空，则说明左侧没有小于x的数</span><br><span class="line">        else&#123;</span><br><span class="line">            cout&lt;&lt;stck[top]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        stck[++top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><hr>
<h3 id="结构特征-3"><a href="#结构特征-3" class="headerlink" title="结构特征"></a>结构特征</h3><p> 单调队列顾名思义，是具有单调性的队列，具体表现为通过入队元素与队尾元素比较再进行操作</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000010;</span><br><span class="line"></span><br><span class="line">int numbers[N];//原数组</span><br><span class="line">int queue[N];//单调队列，此队列中存储的并不是具体的数，而是元素的下标</span><br><span class="line"></span><br><span class="line">//对于queue单调队列，其本身有以下特性：</span><br><span class="line">//1.内部存储的并不是原数组中具体的数，而是其下标</span><br><span class="line">//2.其队首的元素为当前最小的元素，即队首的数总是最小的</span><br><span class="line">//形象的理解滑动窗口，当前三位完成比较时，直接向后滑一位，因为前两位已经比对出更小的那一位了</span><br><span class="line">//且其坐标已经存入了queue队列首位，所以只需要看新加入的一位数的相对大小即可</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=0;i&lt;n;i++) cin&gt;&gt;numbers[i];</span><br><span class="line"></span><br><span class="line">    int head=0,tail=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(head&lt;=tail&amp;&amp;i-k+1&gt;queue[head]) head++;//队列不为空，且最小的一位已经不在滑动窗口内，向后滑动一位</span><br><span class="line">        while(head&lt;=tail&amp;&amp;numbers[queue[tail]]&gt;=numbers[i]) tail--;//入队数大于队尾数，队尾数出列</span><br><span class="line"></span><br><span class="line">        queue[++tail]=i;//直接存储下下标即可</span><br><span class="line">        if(i-k+1&gt;=0)cout&lt;&lt;numbers[queue[head]]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    head=0,tail=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;//大致思路同上，但是具体条件改变</span><br><span class="line">        if(head&lt;=tail&amp;&amp;i-k+1&gt;queue[head]) head++;</span><br><span class="line">        while(head&lt;=tail&amp;&amp;numbers[queue[tail]]&lt;=numbers[i]) tail--;</span><br><span class="line"></span><br><span class="line">        queue[++tail]=i;</span><br><span class="line">        if(i-k+1&gt;=0) cout&lt;&lt;numbers[queue[head]]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展题目:字符串的排列:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">https://leetcode-cn.com/problems/permutation-in-string/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean checkInclusion(String s1, String s2) &#123;</span><br><span class="line">        int m = s1.length(), n = s2.length();</span><br><span class="line">        if (m &gt; n) return false;</span><br><span class="line"></span><br><span class="line">        int[] cnt = new int[26];</span><br><span class="line">        for (char c : s1.toCharArray()) cnt[c - &#x27;a&#x27;]++;</span><br><span class="line">        </span><br><span class="line">        int[] cur = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; m; i++) cur[s2.charAt(i) - &#x27;a&#x27;]++;</span><br><span class="line">        </span><br><span class="line">        if (check(cnt, cur)) return true;</span><br><span class="line">        </span><br><span class="line">        for (int i = m; i &lt; n; i++) &#123;</span><br><span class="line">            cur[s2.charAt(i) - &#x27;a&#x27;]++;</span><br><span class="line">            cur[s2.charAt(i - m) - &#x27;a&#x27;]--;</span><br><span class="line">            if (check(cnt, cur)) return true;</span><br><span class="line">        &#125;//滑动窗口</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    boolean check(int[] cnt1, int[] cnt2) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">            if (cnt1[i] != cnt2[i]) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><hr>
<h3 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h3><p> KMP算法作为一种字符串匹配算法，可在一个字符串S中找出一个词W出现的位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能开始的位置，这种算法可以避免重新检查先前已经匹配过的字符，更加节约时间</p>
<h3 id="暴力写法"><a href="#暴力写法" class="headerlink" title="暴力写法"></a>暴力写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">char p[N];</span><br><span class="line">char s[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    for(int i=0;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int M;</span><br><span class="line">    cin&gt;&gt;M;</span><br><span class="line">    for(int i=0;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bool flag=true;</span><br><span class="line">        for(int j=0;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[j]!=s[i+j])&#123;</span><br><span class="line">                flag=false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag) cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而暴力写法的话，就失去了节约时间的意义，所以我们采用耗时更少的KMP</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p> 在用具体代码实现之前，需要清楚一个重点，就是在两个字符串匹配的时候，分别指向它们的指针都是同步运行，没有改变位置的时候，都是一趟从头到尾，没有多余的操作，而原字符串也是不动的，所有元素中，唯一活动的只有匹配子字符串，它随着自己的遍历指针结合next数组对应的元素而动，三动一不动！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//在kmp算法中，主要由两大重点构成，分别是1.next数组 2.匹配</span><br><span class="line">//1.next数组</span><br><span class="line">//其实next数组非常好得出，举例，比如字符串abcab，我们假设此时对于字符串的遍历指针i已经指到了最后一位，即i=5</span><br><span class="line">//其前缀集合&#123;a,ab,abc,abca&#125;</span><br><span class="line">//其后缀集合&#123;b,ab,cab,bcab&#125;</span><br><span class="line">//通过观察前缀集合以及后缀集合，发现其公共最长前后缀集合串为ab，长度为2，所以next[i]也就是next[5]=2</span><br><span class="line">//示例：字符串p</span><br><span class="line"></span><br><span class="line">for(int i=2,j=0;i&lt;=p.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    while(j&amp;&amp;p[j+1]!=p[i]) j=next[j];//这里其实很好理解，就是字符串p自己和自己匹配，从而得出next数组中的内容</span><br><span class="line">    //当失配时，就可以将此点坐标记录在next中了</span><br><span class="line">    if(p[j+1]==p[i]) j++;</span><br><span class="line">    next[i]=j;//记录下前面与自己匹配的最末坐标</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.匹配</span><br><span class="line">//匹配的思路很简单，与next数组的构造过程相差无几，只是有一些细节需要注意</span><br><span class="line"></span><br><span class="line">for(int i = 1, j = 0; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    while(j &amp;&amp; s[i] != p[j+1]) j = ne[j];</span><br><span class="line">    //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span><br><span class="line">    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span><br><span class="line"></span><br><span class="line">    if(s[i] == p[j+1]) j++;</span><br><span class="line">    //当前元素匹配，j移向p串下一位</span><br><span class="line">    if(j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        //匹配成功，进行相关操作</span><br><span class="line">        j = next[j];  //继续匹配下一个子串</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Trie-字典树"><a href="#Trie-字典树" class="headerlink" title="Trie(字典树)"></a>Trie(字典树)</h2><hr>
<h3 id="结构特征-4"><a href="#结构特征-4" class="headerlink" title="结构特征"></a>结构特征</h3><p> Trie树是经常用来存储字符串集合的一种数据结构，即称为字典树，它的具体结构如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.2xa3c3ujyno0.jpg" alt="image"></p>
<p>从根结点延伸出许多的分支，其中每一条边代表着一个后继字母</p>
<p>将代码和具体结构图像抽象之后，就可以得出下面这张图</p>
<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/BA64E728F2026ECA6758D23B9D1225F7.3in3h4jeka00.jpg" alt="BA64E728F2026ECA6758D23B9D1225F7"></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先我们要清楚idx是干什么的<br>如讲解所说，idx在插入时，就是进行边的开拓，我的理解中，字母代表的是字典树中的边(如有错误请见谅),idx则在不存在此条分支时开拓新的结点为其提供叶子结点且是配合cnt数组进行计数的关键<br>2.我的理解中，p&#x3D;son[p][u]这一步非常的巧妙，进行抽象之后， 发现就是这一步让字典树的查询能进入相应的下一级<br>3.字典树最大的特点，就是存储公共前缀，避免不必要的开支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int son[N][26],cnt[N],idx;</span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">void insert(char *str)  // 插入</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(char *str)  // 查询</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) return 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while (n -- )&#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        if(*op==&#x27;I&#x27;) insert(str);</span><br><span class="line">        else&#123;</span><br><span class="line">            cout&lt;&lt;query(str)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展题目-1"><a href="#扩展题目-1" class="headerlink" title="扩展题目"></a>扩展题目</h3><p>最大异或对:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/145/">https://www.acwing.com/problem/content/description/145/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010, M = N * 31;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int a[N];</span><br><span class="line">int son[M][2], idx;//异或对的话，其trie的结构就是分支只有0和1两种可能性</span><br><span class="line"></span><br><span class="line">void insert(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 30; i &gt;= 0; i--) &#123;</span><br><span class="line">        int u = x &gt;&gt; i &amp; 1;//这句话的意义相当于得到x上第i位的数字</span><br><span class="line">        if (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int x) &#123;</span><br><span class="line">    int p = 0, res = 0;</span><br><span class="line">    for (int i = 30; i &gt;= 0; i--) &#123;</span><br><span class="line">        int u = x &gt;&gt; i &amp; 1;</span><br><span class="line">        if (son[p][!u]) &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res * 2 + !u;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * 2 + u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(a[i]);</span><br><span class="line">        int t = query(a[i]);</span><br><span class="line">        res = max(res, a[i] ^ t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;, res);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><hr>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p> 并查集用来快速处理这样的问题：</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否在同一个集合当中</li>
</ol>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p> 每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点</p>
<p>问题1：如何判断树根：if(p[x]&#x3D;&#x3D;x)</p>
<p>问题2：如何求x的集合编号：while(p[x]!&#x3D;x) x&#x3D;p[x];</p>
<p>问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号。p[x]&#x3D;y</p>
<h3 id="例题描述"><a href="#例题描述" class="headerlink" title="例题描述"></a>例题描述</h3><p>一共有 nn 个数，编号是 1∼n1∼n，最开始每个数各自在一个集合中。</p>
<p>现在要进行 mm 个操作，操作共有两种：</p>
<ol>
<li><code>M a b</code>，将编号为 aa 和 bb 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li>
<li><code>Q a b</code>，询问编号为 aa 和 bb 的两个数是否在同一个集合中；</li>
</ol>
<p>输入格式</p>
<p>第一行输入整数 nn 和 mm。</p>
<p>接下来 mm 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p>
<p>输出格式</p>
<p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 aa 和 bb 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p>
<p>每个结果占一行。</p>
<p>数据范围</p>
<p>1≤n,m≤10^5</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int p[N];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;//返回x的祖宗节点+路径压缩</span><br><span class="line">    if(p[x]!=x) p[x]=find(p[x]);//如果</span><br><span class="line">    return p[x];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    </span><br><span class="line">    while (m -- )&#123;</span><br><span class="line">        char op[2];</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);</span><br><span class="line">        </span><br><span class="line">        if(op[0] ==&#x27;M&#x27;) p[find(a)]=find(b);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(find(a)==find(b)) puts(&quot;Yes&quot;);</span><br><span class="line">            else&#123;</span><br><span class="line">                puts(&quot;No&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目-6"><a href="#拓展题目-6" class="headerlink" title="拓展题目"></a>拓展题目</h3><p>连通块中点的数量:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/839/">https://www.acwing.com/problem/content/839/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line">int n,m;</span><br><span class="line">int p[N],cnt[N];//p数组是父节点数组，cnt数组是每个父节点中节点个数的计数数组</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;//祖宗节点寻找函数</span><br><span class="line">    if(p[x]!=x) p[x]=find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i]=i;</span><br><span class="line">        cnt[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (m -- )&#123;</span><br><span class="line">        string op;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        if(op==&quot;C&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            a=find(a);</span><br><span class="line">            b=find(b);</span><br><span class="line">            if(a!=b)&#123;//如果两个点相同，就没有连接的必要</span><br><span class="line">                p[a]=b;</span><br><span class="line">                cnt[b]+=cnt[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(op==&quot;Q1&quot;)&#123;</span><br><span class="line">            </span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            if(find(a)==find(b))&#123;</span><br><span class="line">                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">            cout&lt;&lt;cnt[find(a)]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>食物链:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/242/">https://www.acwing.com/problem/content/242/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 50010;</span><br><span class="line"></span><br><span class="line">int n,k;</span><br><span class="line">int p[N],d[N];//p[N]是所有物种的根节点，d[N]是物种到根节点的距离</span><br><span class="line"></span><br><span class="line">//这道题可以根据节点距离根节点的长度来确定节点种类</span><br><span class="line">//1.与根节点距离模3余0，则就是根节点同物种</span><br><span class="line">//2.与根节点距离模3余1，则吃根节点代表物种</span><br><span class="line">//3.与根节点距离模3余2，则被根节点吃</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;//寻找根节点函数</span><br><span class="line">    if(p[x]!=x)&#123;</span><br><span class="line">        int t=find(p[x]);//先保存根节点</span><br><span class="line">        d[x]+=d[p[x]];//节点x需要加上其根节点到最终根节点的距离</span><br><span class="line">        p[x]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n;i++) p[i]=i;//定义各自的根节点</span><br><span class="line">    </span><br><span class="line">    int res=0;</span><br><span class="line">    </span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        int t,x,y;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;t,&amp;x,&amp;y);</span><br><span class="line">        </span><br><span class="line">        if(x&gt;n||y&gt;n) res++;</span><br><span class="line">        else&#123;</span><br><span class="line">            int px=find(x),py=find(y);</span><br><span class="line">            if(t==1)&#123;//x和y是同类</span><br><span class="line">                if(px==py&amp;&amp;(d[y]-d[x])%3) res++;//如果x和y是同一种族圈且满足被吃或吃的关系，则为假话</span><br><span class="line">                else if(px!=py)&#123;</span><br><span class="line">                    p[px]=py;//将px的根节点接到y的根节点上</span><br><span class="line">                    d[px]=d[y]-d[x];//d[x]作出相应的更改</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;//吃或被吃情况</span><br><span class="line">                if(px==py&amp;&amp;(d[y]-d[x]+1)%3) res++;</span><br><span class="line">                else if(px!=py)&#123;</span><br><span class="line">                    p[px]=py;</span><br><span class="line">                    d[px]=d[y]+1-d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="结构特征-5"><a href="#结构特征-5" class="headerlink" title="结构特征"></a>结构特征</h3><p> 堆的用途:</p>
<p><strong>插入一个数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[++size]=x;up(size);</span><br></pre></td></tr></table></figure>

<p><strong>求集合当中的最小值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[1]</span><br></pre></td></tr></table></figure>

<p><strong>删除最小值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[1]=heap[size];size--;down(1);</span><br></pre></td></tr></table></figure>

<p><strong>删除任意一个元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heap[k]=heap[size];</span><br><span class="line">size--;</span><br><span class="line">down(k);</span><br><span class="line">up(k);</span><br></pre></td></tr></table></figure>

<p><strong>修改任意一个元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k]=x;</span><br><span class="line">down(k);</span><br><span class="line">up(k);</span><br></pre></td></tr></table></figure>

<p>堆的结构可以抽象为一颗完全二叉树，除开最后一层结点以外上面的层数都是满树</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>堆排序:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/840/">https://www.acwing.com/problem/content/840/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class HeapTest &#123;</span><br><span class="line">    static int N=1000010;</span><br><span class="line">    static int n;</span><br><span class="line">    static int m;</span><br><span class="line">    static int cnt;</span><br><span class="line">    static int[] h=new int[N];</span><br><span class="line"></span><br><span class="line">    public static void down(int u)&#123;//下沉</span><br><span class="line">        int t=u;</span><br><span class="line">        if(u*2&lt;=cnt&amp;&amp;h[u*2]&lt;h[t]) t=u*2;</span><br><span class="line">        if(u*2+1&lt;=cnt&amp;&amp;h[u*2+1]&lt;h[t]) t=u*2+1;</span><br><span class="line">        //这里是三者比较，分别是根节点，右子节点和左子节点一起比较</span><br><span class="line">        if(u!=t)&#123;</span><br><span class="line">            int s=h[u];</span><br><span class="line">            h[u]=h[t];</span><br><span class="line">            h[t]=s;</span><br><span class="line">            down(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc=new Scanner(System.in);</span><br><span class="line">        n=sc.nextInt();</span><br><span class="line">        m=sc.nextInt();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            h[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=n;</span><br><span class="line"></span><br><span class="line">        for(int i=n/2;i!=0;i--) down(i);</span><br><span class="line"></span><br><span class="line">        while(m!=0)&#123;</span><br><span class="line">            System.out.print(h[1]+&quot; &quot;);</span><br><span class="line">            h[1]=h[cnt--];</span><br><span class="line">            down(1);</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目-7"><a href="#拓展题目-7" class="headerlink" title="拓展题目"></a>拓展题目</h3><p>模拟堆:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/841/">https://www.acwing.com/problem/content/841/</a></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><hr>
<h3 id="结构特征-6"><a href="#结构特征-6" class="headerlink" title="结构特征"></a>结构特征</h3><p> 散列表也叫哈希表，是一种根据关键码值(key value)直接进行访问的数据结构，一般情况下是通过模运算得到码值，然后放入对应的散列中</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int N=100003;//这里的模运算数最好是选用大于数据量的第一个质数</span><br><span class="line">    static int[] h=new int[N];//h数组为散列数组，其中存放各个码值对应的拉链</span><br><span class="line">    static int[] e=new int[N];//e数组和下面的ne数组相当于构成链表，也就是拉链</span><br><span class="line">    static int[] ne=new int[N];</span><br><span class="line">    static int idx=0;//记录点的个数</span><br><span class="line"></span><br><span class="line">    static void Insert(int x)&#123;//插入函数</span><br><span class="line">        int k=(x%N+N)%N;//取模运算</span><br><span class="line">        e[idx]=x;</span><br><span class="line">        ne[idx]=h[k];</span><br><span class="line">        h[k]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean find(int x)&#123;</span><br><span class="line">        int k=(x%N+N)%N;</span><br><span class="line">        for(int i=h[k];i!=-1;i=ne[i])&#123;</span><br><span class="line">            if(e[i]==x)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc=new Scanner(System.in);</span><br><span class="line">        Arrays.fill(h,-1);</span><br><span class="line">        int n;</span><br><span class="line">        n= sc.nextInt();</span><br><span class="line">        while(n--&gt;0)&#123;</span><br><span class="line">            String op=sc.next();</span><br><span class="line"></span><br><span class="line">            int x=sc.nextInt();</span><br><span class="line">            if(op.equals(&quot;I&quot;))&#123;</span><br><span class="line">                Insert(x);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(find(x)) System.out.println(&quot;Yes&quot;);</span><br><span class="line">                else&#123;</span><br><span class="line">                    System.out.println(&quot;No&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对于其中的逻辑不太清楚，下面是debug中数据的具体表现</p>
<p>样例数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">I 1</span><br><span class="line">I 2</span><br><span class="line">I 3</span><br><span class="line">I 3</span><br><span class="line">I 2</span><br><span class="line">I 1</span><br><span class="line">Q 1</span><br></pre></td></tr></table></figure>

<p>调试结果:</p>
<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.pztgb3ovi4g.jpg" alt="image"></p>
<h3 id="拓展题目-8"><a href="#拓展题目-8" class="headerlink" title="拓展题目"></a>拓展题目</h3><p>字符串哈希:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/843/">https://www.acwing.com/problem/content/843/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int N=100010,P=131;</span><br><span class="line">    static long[] h=new long[N];</span><br><span class="line">    static long[] p=new long[N];//存放p的n次幂</span><br><span class="line">    public static long get(int l,int r)&#123;</span><br><span class="line">        return h[r]-h[l-1]*p[r-l+1];//相当于把两个区间中的字符串对齐求出哈希值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc=new Scanner(System.in);</span><br><span class="line">        int n=sc.nextInt();</span><br><span class="line">        int m=sc.nextInt();</span><br><span class="line"></span><br><span class="line">        String s= sc.next();</span><br><span class="line">        p[0]=1;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            p[i]=p[i-1]*P;//预处理</span><br><span class="line">            h[i]=h[i-1]*P+s.charAt(i-1);//求下一位的哈希值直接*p加上下一个字符的ascii码值即可</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(m--&gt;0)&#123;</span><br><span class="line">            int l1= sc.nextInt();</span><br><span class="line">            int r1= sc.nextInt();</span><br><span class="line">            int l2= sc.nextInt();</span><br><span class="line">            int r2= sc.nextInt();</span><br><span class="line">            if(get(l1,r1)==get(l2,r2)) System.out.println(&quot;Yes&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(&quot;No&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h2 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h2><hr>
<h3 id="基本思想-8"><a href="#基本思想-8" class="headerlink" title="基本思想"></a>基本思想</h3><p> 深度优先搜索顾名思义，即探索访问一棵树中的叶结点,就好比一颗树中有各条不同的路径，我们的目标就是分别把每一条路走到尽头，达到每一条路的终点即可。</p>
<h3 id="Emphasis-8"><a href="#Emphasis-8" class="headerlink" title="Emphasis"></a>Emphasis</h3><p> dfs深度优先搜索的<strong>精髓</strong>在于其递归回溯过程中对于<strong>条件的书写</strong>以及<strong>还原回溯前状态</strong>的操作,利用好先前所进行的操作改变各结点的访问状态，<strong>在递归过程中加以利用</strong></p>
<h3 id="具体实现-8"><a href="#具体实现-8" class="headerlink" title="具体实现"></a>具体实现</h3><p>例题:</p>
<p>给定一个整数 nn，将数字 1∼n1∼n 排成一排，将会有很多种排列方法。</p>
<p>现在，请你按照字典序将所有的排列方法输出。</p>
<p>输入格式</p>
<p>共一行，包含一个整数 nn。</p>
<p>输出格式</p>
<p>按字典序输出所有排列方案，每个方案占一行。</p>
<p>数据范围</p>
<p>1≤n≤7</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    static int N = 10;</span><br><span class="line">    static int[] path = new int[N];</span><br><span class="line">    static boolean[] st = new boolean[N];//st数组记录第n个数是否被占用，初始时全部false默认为未占用</span><br><span class="line">    static int n;</span><br><span class="line"></span><br><span class="line">    static void dfs(int u) &#123;</span><br><span class="line">        if (u == n) &#123;//path数组中的数字量一旦达到要求数字量，就开始输出</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                System.out.print(path[i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">                if (!st[i]) &#123;//当第i个数未被占用时才可接入</span><br><span class="line">                    path[u] = i;</span><br><span class="line">                    st[i] = true;</span><br><span class="line">                    dfs(u + 1);</span><br><span class="line">                    st[i] = false;//等于false是为了回溯，回到未被占用时候的状态</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc=new Scanner(System.in);</span><br><span class="line">        n= sc.nextInt();</span><br><span class="line">        dfs(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展题目-9"><a href="#拓展题目-9" class="headerlink" title="拓展题目"></a>拓展题目</h3><p>n-皇后问题:<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/845/">https://www.acwing.com/problem/content/845/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 20;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">char chess[N][N];</span><br><span class="line">bool col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    if(u==n)&#123;</span><br><span class="line">        for(int i=0;i&lt;n;i++) puts(chess[i]);</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(!col[i]&amp;&amp;!dg[u+i]&amp;&amp;!udg[n-u+i])&#123;</span><br><span class="line">            chess[u][i]=&#x27;Q&#x27;;</span><br><span class="line">            col[i]=dg[u+i]=udg[n-u+i]=true;</span><br><span class="line">            dfs(u+1);</span><br><span class="line">            col[i]=dg[u+i]=udg[n-u+i]=false;</span><br><span class="line">            chess[u][i]=&#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            chess[i][j]=&#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(0);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS(广度优先搜索)"></a>BFS(广度优先搜索)</h2><h3 id="基本思想-9"><a href="#基本思想-9" class="headerlink" title="基本思想"></a>基本思想</h3><p> 同样是一棵树，在bfs中我们要在所有分支中找到能够走的最远的那条路</p>
<h3 id="Emphasis-9"><a href="#Emphasis-9" class="headerlink" title="Emphasis"></a>Emphasis</h3><p> 注意递归时条件的判断</p>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p>(此题来源于leetcode:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">https://leetcode-cn.com/problems/max-area-of-island/</a>)</p>
<p>给你一个大小为 m x n 的二进制矩阵 grid 。</p>
<p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 1 的单元格的数目。</p>
<p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.5x5wnay4iy40.jpg" alt="image"></p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxAreaOfIsland(int[][] grid) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=0;i&lt;grid.length;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;grid[0].length;j++)&#123;</span><br><span class="line">                ans=Math.max(ans,bfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int bfs(int[][] grid,int i,int j)&#123;</span><br><span class="line">        if(i&lt;0||i&gt;=grid.length||j&lt;0||j&gt;=grid[0].length||grid[i][j]==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=0;</span><br><span class="line">    int count=1;</span><br><span class="line">    count+=bfs(grid,i-1,j);</span><br><span class="line">    count+=bfs(grid,i+1,j);</span><br><span class="line">    count+=bfs(grid,i,j+1);</span><br><span class="line">    count+=bfs(grid,i,j-1);</span><br><span class="line">    return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.5zboyougvjk0.jpg" alt="image"></p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;</span><br><span class="line">        return dfs(image, sr, sc, newColor, image[sr][sc]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[][] dfs(int[][] image, int i, int j, int newColor, int num)&#123;</span><br><span class="line">        //1.坐标越界</span><br><span class="line">        //2.当前坐标已经被染色</span><br><span class="line">        //3.邻近坐标初始值与辐射坐标初始值不同</span><br><span class="line">        if(i&lt;0 || i&gt;=image.length || j&lt;0 || j&gt;=image[0].length || image[i][j]==newColor || image[i][j]!=num)&#123;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int temp=image[i][j];</span><br><span class="line">            image[i][j]=newColor;</span><br><span class="line">            dfs(image, i+1, j, newColor, temp);</span><br><span class="line">            dfs(image, i-1, j, newColor, temp);</span><br><span class="line">            dfs(image, i, j+1, newColor, temp);</span><br><span class="line">            dfs(image, i, j-1, newColor, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h3><p><img src="https://cdn.jsdelivr.net/gh/KevinJinNL/img@main/image.8dm0hfc3ukw.jpg" alt="image"></p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">null</span>&amp;&amp;root2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>((root1==<span class="literal">null</span>?<span class="number">0</span>:root1.val)+(root2==<span class="literal">null</span>?<span class="number">0</span>:root2.val));</span><br><span class="line"></span><br><span class="line">        root.left=mergeTrees(root1==<span class="literal">null</span>?<span class="literal">null</span>:root1.left,root2==<span class="literal">null</span>?<span class="literal">null</span>:root2.left);</span><br><span class="line">        root.right=mergeTrees(root1==<span class="literal">null</span>?<span class="literal">null</span>:root1.right,root2==<span class="literal">null</span>?<span class="literal">null</span>:root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    
    <a href="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="next-post btn btn-default" title='操作系统'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            操作系统</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
    
<div class="utteranc">
  
  <script
    src='https://utteranc.es/client.js'
    repo='shenliyang/snippet-comment'
    issue-term='pathname'
    issue-number=''
    theme='github-light'
    label=''
    crossorigin='anonymous'
    async
  ></script>
</div>



</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-text">基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Emphasis"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE"><span class="toc-text">拓展题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Emphasis-1"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-1"><span class="toc-text">拓展题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-2"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-2"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-2"><span class="toc-text">拓展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-3"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-3"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-3"><span class="toc-text">拓展题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-text">差分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-4"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-4"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">核心思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-4"><span class="toc-text">拓展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-5"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-5"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-5"><span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-5"><span class="toc-text">拓展题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE2"><span class="toc-text">拓展题目2:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-6"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-6"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-6"><span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="toc-text">例题：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-text">区间合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-7"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-7"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-7"><span class="toc-text">具体实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%89%B9%E5%BE%81"><span class="toc-text">结构特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%89%88%E6%9C%AC"><span class="toc-text">数组版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%89%88%E6%9C%AC"><span class="toc-text">指针版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%89%B9%E5%BE%81-1"><span class="toc-text">结构特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%89%88%E6%9C%AC-1"><span class="toc-text">数组版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%89%88%E6%9C%AC-1"><span class="toc-text">指针版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%89%B9%E5%BE%81-2"><span class="toc-text">结构特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%A2%98%E7%9B%AE"><span class="toc-text">扩展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%89%B9%E5%BE%81-3"><span class="toc-text">结构特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-text">KMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81"><span class="toc-text">算法特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E5%86%99%E6%B3%95"><span class="toc-text">暴力写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie-%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-text">Trie(字典树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%89%B9%E5%BE%81-4"><span class="toc-text">结构特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%A2%98%E7%9B%AE-1"><span class="toc-text">扩展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">例题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-6"><span class="toc-text">拓展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%89%B9%E5%BE%81-5"><span class="toc-text">结构特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-7"><span class="toc-text">拓展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%89%B9%E5%BE%81-6"><span class="toc-text">结构特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-8"><span class="toc-text">拓展题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="toc-text">搜索与图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">DFS(深度优先搜索)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-8"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-8"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-8"><span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E9%A2%98%E7%9B%AE-9"><span class="toc-text">拓展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">BFS(广度优先搜索)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-9"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Emphasis-9"><span class="toc-text">Emphasis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-text">例题2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%983"><span class="toc-text">例题3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>